---
output: pdf_document
---

Python学习手册

- Mark Lutz著， 秦鹤、林明译

> 该书的学习目标是：熟悉掌握Python语言本身。（2021-11-17）

# 前沿

**Python的类**基本上仅仅是处理内置类型函数的包。一旦你掌握了内置类型和函数，理解类就相对容易了。  
**函数**是打包代码并重用的一种简单方式，它避免了代码冗余。  
**Python模块**允许你将语句和函数组织为更大的组件。  
**类**一种可选但是强大的组织代码以便定制和重用的方式，使用它能自然地将代码冗余程度降到最低。  
现今的Python拥有内置类型、生成器、闭包、推导、Unicode、装饰器，以及过程式、面向对象及函数式编程范式的混合。

# 问答环节

> 本章介绍Python流行背后的一些主要原因。  

Python注重可读性、一致性和软件质量。代码的长度往往只有C++或Java代码的1/5~1/3。采取了一种所谓极简主义的设计理念。
Python是一门通用型的编程语言，但时常扮演脚本语言的角色。“脚本（script）”往往倾向于描述简单的顶层代码文件，而“程序（program）”则用来描述那些相对复杂一些的多文件应用。
Python重大且普遍的唯一缺点是，与C这类完全编译并且较底层的语言相比，Python的执行速度还不够快。目前，Python的标准实现方式是将源代码的语句编译为字节码（byte code），然后将字节码解释出来。
Python通过C/C++系统进行扩展以及嵌入C/C++系统的特性，使其能够作为一种灵活的粘合语言，可以脚本化处理其他系统的组件的行为。  
Python的类模型支持多态、运算符重载和多重继承等高级概念。  
Python的C语言API可以帮助Python程序灵活调用C语言。

# Python如何运行程序

> 本章学习Python解释器如何执行程序。

**解释器**是一种让其他程序运行起来的程序，是代码与计算机硬件之间的软件逻辑层。
一个**python程序**是一个包含python语句的文本文件。当Python运行脚本时，在代码开始处理之前，Python会首先将脚本编译成所谓的“字节码”，然后将其转发到所谓的“虚拟机”中。**字节码**是一种低级的、与平台无关的表现形式。Python将字节码保存为一个以.pyc为扩展名的文件，放在名为__pycache__的子目录中[^1]。

[^1]:Python这样保存字节码是为了优化启动速度，下一次运行程序时，如果上次保存的程序没有修改，那么Python就会跳过编译这个步骤，直接加载.pyc文件。字节码只针对那些被导入(import)的文件而生成，而不是顶层的执行脚本。

**Python虚拟机**(PVM)是迭代运行字节码指令的一个大循环，一个接一个地完成操作。
Python在程序开始执行之前不需要预编译和链接，只需要简单地输入并运行代码即可。这让其具有浓厚的动态语言色彩：在运行时，Python程序构建并执行另一个Python程序。这种结构让Python能够实现产品定制。因为Python代码可以动态地被修改，用户可以改进系统内部的Python部分，而不需要拥有或编译整个系统的代码。
Python语言有5中主要的实现方式——CPython、Jython、IronPython、Stackless和PyPy[^2]。

[^2]:其中CPython是标准的实现，由可移植的ANSI C语言代码编写而成，Jython的目标是让Python代码能够脚本化Java应用程序，IronPython为了满足在.NET组件中集成Python的开发者，Stackless是标准CPython针对并发性而优化的一个增强实现，PyPy提供了一个即时编译器(Just-In-Time, JIT)，将字节码中的部分直接转换成运行速度更快的二进制机器码，从而运行速度更快。

# 你应如何运行程序

> 本章的目标是学习如何运行Python代码

在命令行输入Python，依赖于系统帮我们在程序搜索路径中定位Python程序的位置。如果没有设置系统的PATH环境变量来包括Python的安装路径，就要输入完整路径来代替单词“python”[^3]。

[^3]:这里讲清楚了系统环境变量PATH的含义：即系统用来搜索应用程序的目录。

为了永久保存程序，需要在文件中写入代码，这样的文件通常叫作模块。**模块**是一个包含了Python语句的简单文本文件。它是Python程序最大的程序结构，也是这门语言的首要概念之一。

Windows的**注册表**是个多层的数据库，用来储存系统和应用程序的配置信息。数据库可以保证多进程、多线程读写不出错。

任何一个以扩展名.py截尾的Python源代码文件都是一个模块，其他文件可以通过导入一个模块来读取这个模块定义的内容。**导入操作**本质上就是载入另一个文件，并给予读取那个文件内容的权限。一个模块的内容通过其属性从而被外界使用[^4]。

[^4]:导入是一个开销很大的操作，以至于每个文件、每个程序不能重复运行多于一次。 如果需要再次导入一个模块，需要调用reload函数。

导入和重载提供了一种自然的程序启动选项，因为导入操作将会在最后一步执行文件[^5]。模块扮演了一个工具库的角色，它往往就是变量名的包（即命名空间），而在那个包中的变量名称就是属性。**属性**就是绑定在特定对象上的变量名。

[^5]:导入就是Python在sys.path里列出的每一个目录中搜索导入的模块：sys.path是sys模块里目录名称字符串的Python列表，它从PYTHONPATH环境变量中获得初始化，加上一个标准目录集。

from语句从模块中复制出变量名，即改变了命名空间。
dir函数，可以获得模块内部的全部变量名列表。

# 介绍Python对象类型

在Python中，我们使用“材料”来处理“事务”。“事务”指的是像加法以及拼接这样的操作形式，而“材料”指的是我们操作的对象。

在Python中，数据以对象的形式出现，Python脚本中的一切都是对象。

Python程序可以分解成模块、语句、表达式以及对象：

1. 程序由模块构成。
2. 模块包含语句。
3. 语句包含表达式。
4. 表达式创建并处理对象。

编程的三大支柱：顺序语句（执行这一条，然后下一条）、选择语句（当那个值为真时，执行这一条）和循环语句（重复执行多次这一条）。

Python**内置对象类型**：
数字、字符串、列表、字典、元组、文件、集合、其他核心类型、程序单元类型、Python实现相关类型

**字面量**可以理解为那些产生对象的表达式，有时也称为常量。

Python中没有类型声明，运行的表达式语法决定了创建和使用的对象的类型。

## 字符串

字符串是由单字符的字符串所组成的序列，其他更一般的序列类型还包括列表和元组。

当给一个变量赋值时就创建了它，当变量出现在一个表达式中时，就会用其值替换它。

可以在Python的方括号中使用任意表达式，而不仅仅是数字字面量。只要Python需要一个值，就可以使用一个字面量、一个变量或任意表达式。

**多态**，即一个操作的意义取决于被操作的对象。

字符串具有**不可变性**，即在创建后不能原位置（in place）改变。例如，不能通过对其某一位置进行赋值而改变字符串，但可以通过建立一个新的字符串并以同一个变量名对其进行赋值。在核心类型中，数字、字符串和元组是不可变的；列表、字典和集合是可变的。

**方法**指的是依赖并作用于对象上的函数，并通过一个调用表达式触发。

Python的工具库是呈层级分布的：可作用于多种类型的通用操作都是以内置函数或表达式的形式出现的（如len(X),X[0]），但是类型特定的操作是以方法调用的形式出现的（如aString.upper()）。

以双下划线开头并结尾的变量名用来表示Python实现细节的命名模式，而这个列表中没有下划线的属性是字符串对象能够调用的方法。

**编码**（coding）是指用代码来表示各组数据资料，使其成为可利用计算机进行处理和分析的信息。代码是用来表示事物的记号，它可以用数字、字母、特殊的符号或它们的组合来表示。

日常接触到的文件分ASCII和Binary两种。前者规定了用0到127的128个数字代表信息的规范编码，包括33个控制码、1个空格，94个形象码（英文字母、数字、标点）。

除了ASCII用掉的128个数字，一个字符占8个2进制位256个数字。其余数字和33个控制符编码方式为Binary。

Unicode即统一码。Unicode是宽字节字符集，它对每个字符都固定使用两个字节，即16为表示。

“文本文件”指ASCII。“二进制文件”指Binary。“通用字符”“万国码”指Unicode“统一码”。

字符串前加“u/U”表示Unicode字符串，一般英文字符在使用各种编码下都可正常解析，所以一般不带u；中文要表明所需编码，否则易出乱码。“r/R”表示非转义的原始字符串。“b：bytes”Python 3.0 的默认str是unicode，bytes与str可互相转化。

.encode()编成b'\...'
.decode()转成码u'\...'

Unicode的操作大部分都能归为与文件之间进行文本的来回传输：文本在存入文件时会被编码成字节，而在读入内存时会被解码成字符（也称“码”）。
字节：bytes
字符：码
编码后是bytes字节，解码后是str字符。

## 列表

**列表**是一个任意类型的对象的位置相关的有序集合，它没有固定的大小。

**列表推导**源自数学中集合的概念。它是一种通过对序列中的每一项运行一个表达式来创建一个新列表的方法，每次一个，从左到右。列表推导是编写在方括号中的，并且由使用了同一个变量名的表达式和循环结构组成。
> doubles = [c*2 for c in 'spam']

列表、集合、字典和生成器都可以用推导来创建。

## 字典

**字典**不是序列，而是一种映射（mapping）。通过键（key）而不是相对位置来存储对象。

通过键来索引一个字典往往是Python中编写搜索的最快方法。

**if/else三元表达式**（实质上是挤在一行中的一条if语句）
> value = D['x'] if 'x' in D else 0

一个**可迭代对象**可以是内存中物理存储的序列，也可以是一个在迭代操作情况下每次产生一个元素的对象——一种“虚拟”的序列。**迭代协议**在响应next之前先用一个对象对iter内置函数做出响应，并在结束时触发一个异常。

## 元组

**元组**（tuple）基本上就是一个不可以改变的列表。功能上，它用来表示确定元素的集合。

## 文件

**文件**是Python代码调用电脑上存放的外部文件的主要接口。

对脚本而言，无论文件包含的数据是什么类型，文件的内容总是字符串。

文本文件把内容显示为正常的str字符串，而二进制文件把内容显示为一个特定的字节字符串。

## 其他核心类型

**集合**是不可变的对象的无序集合。一个集合的行为很想一个有键无值的字典。

因为Python中{}表示字典，所以空集合通过内置函数set来创建。
> s = set()

集合是处理过滤重复对象、分离集合间差异、进行非顺序的等价判断等任务的利器。

集合只能包含不可变的（可哈希化的）对象类型。列表和字典不能嵌入到集合中。集合本身也是可变的，因此不能直接嵌入到其他集合中。如果需要在另一个集合中存储一个集合，可以像调用set一样调用内置函数frozenset，但fronzenset会创建一个不可变的集合。

**十进制数**
> import decimal
> d = decimal.Decimal('3.141')

**分数**
> from fractions import Fraction
> f = Fraction(2,3)

**布尔值**(预定义的True和False对象实际上定制化的1和0)

**None**是特殊的占位符，通常用来初始化变量和对象。None是一个真正的对象，有一块真实的内存，None是Python给定的一个内置名称。

## 用户定义的类

**类**定义了新的对象类型，扩展了核心类型。

隐含的"self"对象是我们把这叫作面向对象模型的原因：一个类中的函数总是有一个隐含的对象。

# 数值类型

在Python中，数据采用了对象的形式。

在Python中，数字并不真的只是一种对象类型，而是一组相似类型的分类。Python不仅支持通常的数值类型（整数和浮点数），还提供了字面量来直接创建数字和表达式以处理数字。

**字面量**（literal）用于表达源代码中一个固定值的表示法（notation），整数、浮点数以及字符串等都是。总之，字面量就是没有用标识符封装起来的量，是“值”的原始状态。**标识符**是编程时使用的名字。

完整的Python数值类型工具包括：整数和浮点对象、复数对象、小数：固定精度对象、分数：有理数对象、集合：带有数值运算的集合体、布尔值：真和假、内置函数和模块：round|math|random等、表达式；无限制整数精度；位运算；十六进制|八进制|二进制格式、第三方扩展：向量|库|可视化|作图等。

十六进制数以0x或0X开头，后面接十六进制的数字0-9和A-F。八进制数字面量以数字0o或0O开头，后面接着数字0-7构成的数字串。二进制字面量以0b或0B开头，后面跟二进制数字0-1。内置函数hex(I)、oct(I)、bin(I)把一个整数转换为这3种进制表示的字符串。

**复数**字面量为实部+虚部，虚部以j或J结尾。从内部看，复数是通过一对浮点数实现的。复数也可以通过内置函数complex(real, imag)来创建。

**表达式**是处理数字最基本的工具，表达式的定义是：数字（或其他对象）与运算符相组合，并被Python在执行时计算为一个值。

**变量**就是名称，可以用于记录程序中的信息。

str和repr显示格式
从技术上来说，默认的交互式命令行显示和print的区别，相当于内置repr和str函数的区别。str和repr都会把任意对象转换成对应的字符串表示：repr会产生看起来像代码的结果。str转换为一种通常对拥护更加友好的格式。对象同时拥有这两种方式：str用于一般用途，repr带有额外细节。

浮点数因为有限的比特位数，而不能精确地表示某些值的事实，是数值编程的一个基本问题。

X/Y是经典除法和真除法。
X//Y是向下取整除法。

**模块**是外部的组件，而内置函数则位于一个隐含的命名空间内，而Python会自动在这个命名空间中搜索程序中的名称。
> Python的标准库模块是builtins

**布尔型**，名称True和False是bool的实例，而bool实际上只是内置整数类型int的自雷。True和False的行为与整数1
和0是一样的，只不过有独特的显示逻辑。

## 数值扩展

数值编程是Python的一个热门领域。一个叫作NumPy的可选Python扩展提供了高级的数值编程工具。

# 动态类型

动态类型以及由它提供的多态性，这些概念是Python语言简洁性和灵活性的基础。

在Python中，类型是在运行时自动决定的，而不是通过代码声明。

**变量创建**，一个变量（也就是变量名），当代码第一次给它赋值时创建了它，之后的赋值将会改变已创建的变量名的值。
**变量类型**，变量永远不会拥有任何和它关联的类型信息或约束。类型的概念存在于对象，而不是变量名中。
**变量使用**，当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。

在Python中，从变量到对象的链接称作引用。引用是一种关系，通过内存中的指针的形式来实现（在内部，变量事实上是到对象内存空间的一个指针）。

每一个对象都有两个标准的头部信息：类型标志符（type designator）标识这个对象的类型；引用的计数器（reference counter）决定何时收回这个对象。

在Python中，每当一个变量名被赋予一个新的对象，如果原来的对象没有被其他的变量名或对象所引用的话，那么之前的那个对象占用的空间就会被回收。这种自动回收对象空间的技术叫作垃圾回收。在内部，Python在每个对象中保留了一个计数器，计数器记录当前指向该对象的引用的数目。一旦这个计数器被设置为零，这个对象的额内存空间就会自动回收。

对于支持原位置修改的对象类型，共享引用时要加倍小心，因为对一个变量名的修改会影响其他的变量。考虑到所有的赋值都是基于引用，这种风险普遍存在。要避免这个问题，可以复制（copy）对象，而不是创建引用。

# 字符串基础

对于一些程序员，尤其是互联网领域工作的那些而言，Unicode是一个关键工具。

Python分别使用字符串对象类型和文件接口，用来区分文本和二进制数据。Python有三种字符串类型：str用于Unicode文本（包括ASCII），bytes用于二进制数据（包括已编码的文本），而bytearray是bytes的一个可修改的变体。

字符串是我们将要学习的名为序列的一大类对象的第一个代表。

## 常见的字符串字面量和操作

s = ''      空字符串
s = "spam's"    双引号，和单引号相同
s = 's\np\ta\x00m'    转义序列
s = """...multiline..."""   三引号块字符串
s = r'\temp\spam'   原始字符串（不进行转义）
B = b'sp\xc4m'  3.X中的字符串
U = u'sp\u00c4m'    Unicode字符串
s1+s2   拼接
s*3 重复
s[i]    索引
s[i:j]  分片
len(s)  长度
"a %s parrot" % kind    字符串格式化表达式
"a {0} parrot".format(kind)     3.X中的字符串格式化方法
s.find('pa')    字符串方法：搜索
s.rstrip()  移除右侧空白
s.replace('pa', 'xx')   替换
s.split(',')    用分隔符分组
s.isdigit()     内容测试
s.lower()   大小写转换
s.endwith('spam')   尾部测试
'spam'.join(strlist)    分隔符连接
s.encode('latin-1') Unicode编码
B.decode('utf8')    Unicode解码等
for x in s: print(x)    迭代
'spam' in s     成员关系
[c*2 for c in s]    成员关系
map(ord, s)     ord返回单个字符的ASCII序号
re.match('sp(.*)am', line)  模式匹配：库模块

在Python字符串周围，单引号和双引号字符是可以互换的。支持这两种形式的原因是，你不进行反斜杠转义就可以在一种引号的字符串中包含另一种引号。

反斜杠用来引入特殊的字符编码，称为转义序列。

## 字符串反斜杠字符

\newline    被省略（行的延续）
\\  反斜杠（保留一个\）
\`  单引号（保留`）
\"  双引号（保留"）
\a  响铃
\b  退格
\f  换页
\n  换行
\r  回车
\t  水平制表符
\v  垂直制表符
\xhh    十六进制值hh的字符（准确为2个数位）
\ooo    八进制值ooo的字符（可达3个数位）
\0      空字符：二进制的0字符
\N{id}  Unicode数据库ID
\uhhhh  16位十六进制值的Unicode字符
\Uhhhhhhhh      32位十六进制值的Unicode字符
\other  不转义（保留\和other）

**方法调用语法**

函数就是代码包，而方法调用同时结合了属性获取和函数调用。

**属性获取**，具有object.attribute形式的表达式可以理解为“获取对象object中attribtue属性的值”。

**调用表达式**，具有function(arguments)形式的表达式可以理解为：“调用函数function的代码，向其传递零个或多个逗号分隔的参数argument对象，并且返回函数function的结果值。”

两个合用，可以调用一个对象方法：object.method(arguments)

## 字符串格式化表达式

字符串格式化表达式：'...%s...' % (values)

- 在%运算符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或多个内嵌的转换目标，都以%开头(如%d)
- 在%运算符右侧放置一个或多个，内嵌在元组中的对象，这些对象将会插入到你想让python进行格式化的左侧的字符串中，并替换一个或多个转换目标
  - 用法: 'This is %d %s bird!' % (1, 'dead')
- 字符串格式化的类型码
  - s 字符串
  - r 与s相同，但使用repr，而不是str
  - c 字符（int或str）
  - d 十进制数字
  - o 八进制整数
  - x 十六进制整数
  - X 与x相同，但是使用大写字母
  - e 带有指数的浮点数，小写
  - E 与e相同，但是使用大小写字母
  - f 十进制浮点数
  - F 与f相同，但是使用大写字母
  - g 浮点数e或f
  - G 浮点数E或F
  - % %字面量（编码为%%）
- 转换目标的一般结构：%[(keyname)][flags][width][.precision]typecode
  - 在%和类型码字符之间，可以为索引在表达式右侧使用的字典提供键名称，罗列出说明格式的标签，如左对齐（-）、数值符号（+）、正数前的空白以及负数前的-（空格）和零填充（0），被替换的文本给出总的最小字段宽度，为浮点数设置小数点后显示的位数
  - 用法：x = 1234, res = 'integers: ...%d...%-6d...%06d' % (x,x,x)
- 基于字典的格式化表达：字符串格式化同时也允许左边的转换目标引用右边编写的字典中的键来提取对应的值。
  - 用法：'%(qty)d more %(food)s' % {'qty':1, 'food': 'spam'}

字符串格式化方法调用: '...{}...'.format(values)

- 用法:
  - '{motto}, {0} and {food}'.format(42, motto = 3.14, food = [1, 2])
  - 'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})
  - 'My {map[kind]} runs {sys.platform}'.format(sys=sys, map={'kind': 'laptop'})
- 格式化字符串中添加额外的语法：{fieldname component !conversionflag: formatspec}
  - fieldname是辨识参数的一个可选的数字或关键字
  - component是有着大于等于零个".name"或“[index]”引用的字符串，它可以被省略以使用完整的参数值。
  - conversionflag如果出现则以!开始，后面跟着r、s或者a，在这个值上分别调用repr、str或ascii内置函数
  - formatspec如果以:开始，后面跟着文本，制定了如何表示该值，包括字段宽度、对齐方式、补零、小数精度等细节，并且以一个可选地额数据类型码结束。
  - 冒号后面的formatspec组件本身也有着丰富的格式，形式上的描述如：[[fill][align][sign][#][0][width][,][.precision][typecode]]
- 用法：
  - '{0:10} = {1:10}'.format('spam', 123.4567)
  - '{0:>10} = {1:<10}'.format('spam', 123.4567)
  - '{0.platform:>10} = {1[kind]:<10}'.format(sys, dict(kind='laptop'))
  - '{0:f}, {1:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159)

format方法拥有%表达式所没有的很多高级功能。
> data = dict(platform=sys.platform, kind='laptop')
> 'My {kind:<8} runs {platform:>8}'.format(**data)
> 这里方法调用中的**data是特殊的语法，它把一个由键值对组成的字典解包为一组组像“name=value”的关键字参数。

Python中的三大操作类型：

1. 数字（整数、浮点数、小数、分数等）。支持加法和乘法等。
2. 序列（字符串、列表、元组）。支持索引、分片和拼接等。
3. 映射（字典）。支持按键名称的索引等。

Python中的主要核心类型划分为两类：

1. 不可变类型（数字、字符串、元组、不可变集合）。不可变类别中的对象类型都不支持原位置修改。
2. 可变类型（列表、字典、集合、字节数组）。可变类型总是可以在原位置修改，而不用创建新的对象。

# 列表与字典

列表是Python中最具灵活性的有序集合对象类型。

列表是：任意对象的有序集合；通过偏移访问；可变长度、异构以及任意嵌套；属于“可变序列”的分类；对象引用数组（在标准python解释器内部，列表就是c数组而不是链接结构）。

## 常用列表字面量和操作

- for x in L: print(x)  迭代
- 3 in L    成员关系
- L.append(4)   尾部添加
- L.extend([5,6,7]) 尾部扩展
- L.insert(i, x)    插入
- L.index(x)    索引
- L.count(x)    统计元素出现次数
- L.sort()  排序
- L.reverse()   反转
- L.copy()  复制
- L.clear() 清除
- L.pop(i)  删除i处元素
- L.remove(x)   删除元素x
- del L[i]  删除i处元素
- del L[i:j]    删除i到j处的片段
- L[i:j] = []   删除i到j处的片段
- L[i] = 3
- L[i:j] = [4 ,5, 6]    分片赋值
- L = [x**2 for x in range(5)]  列表推导和映射
- list(map(ord, 'spam'))

**列表推导**只不过是通过对序列（事实上，可以推广到鄋的可迭代对象）中的每一项应用一个表达式来构建一个新的列表的方式。

- res = [c*4 for c in 'SPAM']
内置函数map能实现类似的效果，但对序列中的各项应用一个函数并把结果收集到一个新的列表中：
- list(map(abs, [-1, -2, 0, 1, 2]))

L.append(x)与L+[x]的结果类似，不同的是，前者会原位置修改L，而后者会生成新的列表。

- 表达式会创建新的对象。

字典的索引是一种非常快速的搜索操作。字典是作为散列表来实现的。

Python字典的主要属性：通过键而不是偏移量来读取；任意对象的无序集合；长度可变、异构、任意嵌套；属于“可变映射”类型；对象引用表（散列表）。

## 常见字典字面量和操作

- D = {}    空字典
- D = {'name': 'Bob', 'age': 40}    有两个元素的字典
- E = {'cto': {'name': 'Bob', 'age': 40}}   嵌套
- D = dict(name = 'Bob', age = 40)  其他构造方法：关键字
- D = dict([('name', 'Bob'), ('age', 40)])  键值对
- D = dict(zip(keyslist, valslist)) 拉链式键值对
- D= dict.fromkeys(['a', 'b'])  键列表
- D['name'] 通过键索引
- E['cto']['age']   嵌套索引
- 'age' in D    成员关系：键存在测试
- D.keys()  方法：所有键
- D.values()    所有值
- D.times() 所有“键+值”元组
- D.copy()  复制（顶层的）
- D.clear() 清除（删除所有项目）
- D.update(D2)  通过键合并
- D.get(key, default?)  通过键获取，如果不存在默认返回None
- D.pop(key, default?)  通过键删除，如果不存在返回错误
- D.setdefault(key, default?)   通过键获取，如果不存在默认设置为None
- D.popitem()   删除/返回所有的（键，值）对
- len(D)    长度（储存的键值对的对数）
- D[key] = 42   新增/修改键，删除键
- del D [key]   根据键删除条目
- list(D.keys())
- D1.keys() & D2.keys()
- D = {x: x*2 for x in range(10)}   字典推导

在Python标准库中，有可以维护键插入顺序的扩展类型，参见collections模块中的OrderedDict，不过它们通过使用额外空间并降低速度来实现其功能。

在字典中一个键只有一个值，但一个值可以有多个键与之对应，并且一个值本身可以是一个集合。

# 元组、文件与其他核心类型

**元组**是任意对象的有序集合；通过偏移量存取；属于“不可变序列”；固定长度、多样性、任意嵌套；对象引用的数组。

## 常见元组字面量和运算

- ()  空元组  
- T= (0, )  单个元素的元组
- T = (0, 'Ni', 1.2, 3)   四个元素的元组
- T= 0, 'Ni', 1.2, 3  另一种四个元素的元组
- T = ('Bob', ('dev', 'mgr'))   嵌套元组
- T = tuple('spam')   一个可迭代对象的元素组成的元组
- T[i]  索引
- T[i][j] 索引的索引
- T[i:j]  分片
- len(T)  长度
- T1+T2 拼接
- T*3 重复
- for x in T: print(x)  迭代
- 'spam' in T 成员关系测试
- [x**2 for x in T]
- T.index('Ni') 搜寻方法
- T.count('Ni') 计数方法
- namedtuple('Emp', ['name', 'jobs']) 有名元组扩展类型

要注意，元组的不可变性只适用于元组本身**顶层**而非其内容。

列表推导实际上可以被视作一种迭代工具。

文件是计算机中由操作系统管理的具有名称的存储区域。

内置函数open能够创建一个对象，作为到计算机上某个文件的链接。

## 常见的文件操作

- output = open(r'C:\spam', 'w')  创建输出文件('w'代表写入)
- input = open('data', 'r') 创建输入文件('r'代表读入)
- input = open('data')  与上一行相同('r'是默认值)
- aString = input.read()  把整个文件读进一个字符串
- aString = input.read(N) 读取接下来的N个字符到一个字符串
- aString = input.readline()  读取下一行(包含\n换行符)到一个字符串
- aList = input.readlines() 读取整个文件到一个字符串列表(包含\n换行符)
- output.write(aString) 把字符串(或字节串)写入文件
- output.writelines(aList)  把列表内所有字符串写入文件
- output.close()  手动关闭
- output.flush()  把输出缓冲区刷入硬盘中，但不关闭文件
- anyFile.seek(N) 把文件位置移动到偏移量N处以便进行下一个操作
- for line in open('data'): use line  文件迭代器逐行读取
- open('f.txt', encoding='latin-1') Unicode文本文件(str字符串)
- open('f.bin', 'rb') 字节码文件

程序调用内置函数open打开一个文件，open函数返回一个文件对象，这个对象带有可以传输数据的方法：
>>> afile = open(filename, mode)
>>> afile.method()
>>> open('test', mode='w+', encoding='utf-8')

- open函数的第1个参数是外部文件名，它可能含有一个与平台相关的绝对或相对路径前缀。如果没有这个目录路径，文件被默认为存在当前工作目录下。
- open函数的第2个参数是处理模式，字符串'r'表示以输入模式打开，'w'表示以输出模式生成并打开文件，'a'表示在文件尾部追加内容并打开文件。
- open函数的第3个参数可选，能够控制输出缓冲：'0'意味着输出无缓冲。
- 在模式字符串中加上b可以进行二进制数据的处理。加上"+"意味着被打开文件同时支持输入输出。

在任何情况下，文件的文本在Python程序中都采用字符串的形式。读取文件时会返回字符串形式的文本，写入文件时的文本作为字符串被传入write方法。

文件读写方法提示：文件迭代器最适合逐行读取；内容是字符串，不是对象；文件是被缓冲的以及可定位的；close通常是可选地：回收时自动关闭。

如果想逐行扫描一个文本文件，文件迭代器往往是最佳选择：
>>> for line in open('myfile.txt'):
>>> print(line, end='')

- 这种形式通常最容易编写，有更高的内存使用效率，并且比其他方式都更快。

**文本文件**把内容表示为常规的str字符串，自动执行Unicode编码和解码，并且默认执行末行转换。
**二进制文件**把内容表示为一个特殊的bytes字节串类型，并且允许程序不修改地访问文件内容。
在Python3.X中，所有的字符串事实上都是Unicode。

存储Python原生对象：pickle
> pickle模块是能够让我们直接在文件中存储几乎任何Python对象的高级工具，同时不需要我们对字符串进行来回转换。
存储字典：
>>> D = {'a':1, 'b':2}
>>> F= open('datafile.pkl', 'wb')
>>> import pickle
>>> pickle.dump(D, F)
>>> F.close()
取回字典对象：
>>> F = open('datafile.pkl', 'rb')
>>> E = pickle.load(F)
>>> E
{'a':1, 'b':2}

用JSON格式存储Python对象：
> JSON是一种新兴的数据交换格式，既是语言无关的，也支持多种系统。
>>> rec = dict(first='Bob', last='Smith')
>>> import json
>>> s = json.dumps(rec)
>>> o = json.loads(s)
>>> o
{'first':'Bob','last':'Smith'}

存储打包二进制数据：struct
> struct模块能够构造并解析打包二进制数据，即能够把文件中的字符串转换为二进制数据。
>>> F = open('data.bin', 'wb')
>>> import struct
>>> data = struct.pack('>i4sh', 7, b'spam', 8)
>>> data
b'\x00\x00\x07spam\x00\x08'
>>> F.write(data)
>>> F.close()

>>> = open('data.bin', 'rb')
>>> data = F.read()
>>> data
b'\x00\x00\x07spam\x00\x08'
>>> values = struct.unpack('>i4sh', data)
>>> values
(7, b'spam', 8)

文件上下文管理器：
>>> with open(r'C:\code\data.txt') as myfile:
>>> for line in myfile:
>>> ... use line here ...

- with上下文管理器方案能保证操作系统资源的释放，并且对于确保刷新输出文件缓冲区更加有用。

赋值操作**总是**存储对象的引用，而不是这些对象的副本。如果你不想这么做，就要显式地告诉Python复制该对象。

进行复制的操作：

- 没有参数的分片表达式(L[:])可以复制序列。
- 字典、集合或列表的copy方法。
- 诸如list、dict、set的内置函数可以进行复制。
- copy标准库模块能够在需要时创建完整副本。
- 注意：无参数的分片以及字典的copy方法只能进行顶层复制，不能复制嵌套的数据结构。如果需要创建深层嵌套数据结构，可以使用标准库copy模块: copy.deepcopy()。

**引用**是其他语言中指针的更高级模拟。
如果一个复合对象包含指向自身的引用，就称之为循环对象：
>>> L = ['grail']
>>> L.append(L)
>>> L
['grail', [...]]

Python系统中的一切都是对象类型，而且可以由Python程序来处理。

# Python语句简介

Python程序的结构：

1. 程序由模块构成
2. 模块包含语句
3. 语句包含表达式
4. 表达式创建并处理对象

## Python语句

- 赋值  创建引用值  a, b = 'good', 'bad'
- 调用与其他表达式  运行函数  log.write("spam, ham")
- print调用 打印对象  print('The Killer', joke)
- if/elif/else  选择动作  if"python" in text: print(text)
- for/else  序列迭代  for x in mylist: print(x)
- while/else  通用循环  while X > Y:\\ print('hello')
- pass  空占位符  while True:\\ pass
- break 循环退出  while True:\\ if exittest(): break
- continue  循环继续  while True:\\ if skiptest(): continue
- def 函数与方法  def f(a, b, c=1, *d):\\ print(a+b+c+d[0])
- return  函数结果  def f(a, b, c=1, *d):\\ return a+b+c+d[0]
- yield 生成器函数  def gen(n):\\ for i in n: yield i*2
- global 命名空间  x = 'old'\\  def function():\\ global x, y; x = 'new'
- nonlocal  命名空间  def outer():  x = 'old'\\ def function():\\ nonlocal x; x = 'new'
- import  获取模块  import sys
- from  获取属性  from sys import stdin
- class 构建对象  class Subclass(Superclass):\\ staticData = []\\def method(self): pass
- try/except/finally  捕捉异常  try:\\ action()\\ except:\\ print('action error')
- raise 触发异常  raise EndSearch(location)
- assert  调试检查  assert X> Y, 'x too small'
- with/as 上下文管理器  with open('data') as myfile:\\ process(myfile)
- del 删除引用  del data[k]\\ del obj.attr\\del variable

Python所有复合语句都有冒号(：)，置于首行的结尾处。
Python一行的结束会自动终止该行的语句，所以可以省略结尾的(；)号。
如果要让一条语句跨越多行，可以用括号把语句括起来，或者在上一行结尾加反斜杠(\)。
缩进的结束就是代码块的结束。

# 赋值、表达式和打印

赋值语句创建对象引用，而不是复制对象；变量在首次赋值时会被创建；变量在引用前必须先赋值；某些操作会隐式地进行复制（模块导入、函数和类定义、for循环变量、函数参数）。

赋值语句形式：

- spam = 'Spam'   基础形式
- spam, ham = 'yum', 'YUM'    元组赋值（基于位置）
- [spam, ham] = ['yum', 'YUM']    列表赋值（基于位置）
- a, b, c, d = 'spam'   推广的序列赋值
- a, *b = 'spam'    扩展序列解包
- spam = ham = 'lunch'    多目标赋值
- spams += 42   增量赋值

带有单个星号的名称*x，可以用在赋值目标中，来制定对于序列的一个通用匹配方式：带星号的名称会被赋值一个列表，该列表收集了序列中剩下的没被赋值给其他名称的所有项。要是带星号的名称只匹配到单个的项，也向其赋值一个列表，如果剩下的内容为空，则赋值一个空列表。

## 增量赋值语句

- x += y
- x &= y
- x -= y
- x |= y
- x *= y
- x ^= y
- x /= y
- x >>= y
- x %= y
- x <<= y
- x **= y
- x //= y

增量赋值适用于任何支持了相应二元表达式的对象类型。

增量赋值语句的优点：

- 减少程序员的输入。
- 左侧只需计算一次。而在完整形式 x = x+y中，x会出现2次，所以也必须执行两次。
- 增量赋值有着自动选择的优化技术。

拼接操作必然会创建一个新对象，把加号左侧和右侧的列表都复制到其中。相反，原位置方法调用直接在一个内存块末尾添加项。

变量命名规则：

- 语法：（下划线或字母）+（任意数目的字母、数字或下划线）
- 区分大小写：SPAM和spam并不同
- 禁止使用保留字
- 以单一下划线开头的名称(_x)不会被from module import *语句导入
- 前后均有双下划线的名称(**x**)是系统定义的名称，对解释器有特殊意义
- 以双划线开头，但结尾没有双下划线的名称(__x)是外围类的本地变量
- 通过交互式命令行运行时，只有单个下划线的名称(_)会保存最后一个表达式的结果。

## 常见的Python表达式语句

- spam(eggs, ham)   函数调用
- spam.ham(eggs)    方法调用
- spam    在交互式解释器中打印变量
- print(a,b,c,sep='')   打印
- yield x**2    yield表达式语句

表达式语句常常用于执行可以在原位置修改列表的列表方法：
>>> L = [1, 2]
>>> L.append(3)
>>> L
[1, 2, 3]
然而，Python初学者时常把这种操作写成赋值语句：
>>> L = L.append(4)
>>> print(L)
None

## 打印操作

- 标准输出流，也常称stdout，是发送一个程序文本输出的默认位置。
- print函数形式：print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
  - sep是在每个对象的文本之间插入的一个字符串，默认是一个空格。
  - end是添加在打印文本末尾的一个字符串，默认是一个\n换行符。
  - file指定了文本将要发送到文件、标准流或其他类似文件的对象，默认是sys.stdout。
  - flush立即刷新输出，默认是false。

打印流重定向

- print(x)等价于sys.stdout.write(str(x)+'\n')
- 可以sys.stdout赋值给标准输出流以外的对象，例如：

>>> import sys
>>> sys.stdout = open('log.txt', 'a')
>>> print(x)

- 通过将sys.stdout重设指向文件log.txt，之后print语句**都会**将文本写至文件log.txt的末尾。
- file关键字也可以将打印重定向: print(x, file='log.txt')

# if测试和语法规则

复杂if语句：
>>> if choice = 'ham':
            print(1.25)
        elif choice = 'eggs'"
            print(0.99)
        else:
            print(2.02)
上面语句等价于：
>>> print({'ham': 1.25,
                   'eggs': 0.99,
                   'bacon': 2.02}[choice]
)
还等价于：
>>> branch = {'ham': 1.25,
                         'eggs': 0.99,
                         'bacon': 2.02}
>>> print(branch.get('ham', 'Bad choice'))

- 运行if选择分支比较慢，如果用字典判断更快。

## Python语法规则

- 语句是逐个运行的，除非遇到if等控制流语句。
- 快和语句的边界会自动被解释器识别。
- 符合语句 = 首行 + ":" + 多个缩进语句。
- 空白行、空格以及注释通常都会被忽略。
- 文档字符串(docstring)会被忽略，但会被保存并由工具显示。

## 三种布尔表达式运算符

- X and Y
- X or Y
- not X

> 布尔运算符在Python中是单词（不是C语言中的&&、||和!）。
> 布尔and和or运算符在Python中会返回真或假对象，而不是True或False
> or表达式，Python会由左到右计算操作对象，并返回第一个为真的操作对象，并且在其找到第一个真值操作数的地方停止:
>>> 2 or 3, 3 or 2
(2, 3)
>>> [] or 3
3
>>> [] or {}
{}
> 因为or运算符会返回其左右的两个对象之一，这称为Python中相当常见的代码编写技巧：从一个固定大小的集合中选择非空的对象：
>>> X = A or B or C or None
> 这会把X设为A、B、C中第一个非空的对象；如果都为空则设为None。

if/else三元表达式:
>>> A = Y if X else Z

因为所有对象本质都是真或假，所以在Python中，直接测试对象(if X:)比空值比较(if X != '':)更为常见和简单。

# while循环和for循环

while语句提供了一种编写通用循环的方式；for语句可以遍历序列或其他可迭代对象内的元素，并对每一个元素运行一段代码块。

while语句最完整的形式是：首行以及测试表达式有一行或多行正常缩进语句构成的主体以及一个可选的else部分：
>>> while test:
      statements
    else:
      if test: break
      if test: continue
      statements

break：跳出最近所在的外围循环。

continue：跳到最近所在外围循环的头部。

pass：什么事也不做，只是一条空占位语句。

循环else块：当且仅当循环正常离开时才会执行（也就是没有碰到break语句）。

for循环是一个通用的序列迭代器：它可以遍历任何有序序列或其他可迭代对象内的元素。for循环首行制定一个赋值目标，以及你想遍历的对象，后面跟你想重复的语句块：
>>> for target in object:
      statements
      if test: break
      if test: continue
    else:
      statements

对于逐行读取文本文件，for循环是最易于编写且执行最快的：
>>> for line in open('test.txt').readlines():
      print(line.rstrip())

- readlines方法一次性把文件载入成每行字符串的列表。

>>> for line in open('test.txt'):
      print(line.rstrip())

- 该例借助文件迭代器自动在每次循环迭代的时候读入一行。

通常for循环比while循环更容易写，执行的更快。因为for由迭代器实现，而迭代器在Python内部以C语言的速度运行。while循环版本则通过虚拟机运行Python字节码。

Python提供了一套内置函数，可以帮你在for循环中定制迭代：

- range返回一系列连续增加的整数，可作为for中的索引。
- zip返回一系列并行元素的元组，可用于在for中遍历多个序列。
- enumerate同时生成可迭代对象中元素的值和索引，因而我们不必再手动计数。

## 修改列表

对于列表L = [1,2,3]，用for x in L: x += 1这种方式并不奏效，因为你修改的是循环变量x，而不是列表L。要在遍历列表时对其进行修改，必须借助索引：
>>> for i in range(len(L)):
      L[i] += 1
用列表表达式更好：
>>> [x+1 for x in L]

# 迭代和推导

 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次迭代，而每一次迭代得到的结果会作为下一次迭代的初始值。

 列表推导是对可迭代对象中的项应用一个表达式的for循环的一种近似形式。

 **可迭代对象**，本质上是序列观念的一种通用化，如果对象是实际保存的序列或者可以在迭代工具上下文中一次产生一个结果的对象，那么都可以看作是可迭代的。总之，可迭代对象包括实际序列，以及能按照需求计算的虚拟序列。

**可迭代对象**（iterable）指一个支持iter调用的对象。
**迭代器**（iterator）指一个支持next(I)调用的对象。
**生成器**（generator）指能自动支持迭代协议的对象，因此生成器本身就是可迭代对象，不过所有的生成器都能产生和结果。
**迭代协议**：所有带有__next__方法的对象会前进到下一个结果，而当到达一系列结果的末尾时，__next__会引发StopIteration异常，这种对象在Python中也称为迭代器。

## 完整的迭代协议

该协议基于分别用在不同的两个步骤中的两种对象：

1. 可迭代对象：迭代的被调对象，其__iter__方法被iter函数所调用。
2. 迭代器对象：可迭代对象的返回结果，在迭代过程中实际提供值的对象。它的__next__方法被next运行，并在结束时出发StopIteration异常。
文件本身就是迭代器，只支持一次迭代，它有自己的__next__方法，不需要返回一个不同的对象。
列表等内置对象，由于本身不是迭代器，因此支持多次迭代，必须用iter来启东迭代：

>>> L = [1,2,3]
>>> I = iter(L)
>>> I.**next**()
1
>>> next(I)
2

for循环在开始时，首先把可迭代对象传入内置函数iter，拿到一个迭代器。而iter调用返回的迭代器对象有着所需的next方法。iter函数与next和__next__很像，在它内部调用了__iter__方法。

## 扩展的列表推导语法

- 筛选分句：if

>>> lines = [line.rstrip() for line in open('script2.py') if line[0] == 'p']

- 嵌套循环：for

>>> [x + y for x in 'abc' for y in 'lmn']
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']

map是一个内置函数，作用是把一个函数调用应用于传入的可迭代对象中的每一项。
>>> map(str.upper, open('script2.py'))
<map object at 0x00000000029476D8>
>>> list(map(str.upper, open('script2.py')))
['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X=2\n']

*arg形式，会把一个集合的值解包为单个的参数：
>>> f(*[1,2,3,4])

# 文档

## Python文档资源

形式    作用

# 注释   源文件文档

dir函数 以列表显示对象中可用的属性
文档字符串:**doc**    附加在对象上的源文件文档
PyDoc:help函数      交互式命令行中的对象帮助
PyDoc:HTML报告      浏览器中的模块文档
Sphinx第三方工具    为大型项目提供更丰富的文档
标准手册集      官方的语言和库描述
网络资源        在线教程、示例等
已出版的书籍    商业化加工后的参考文本

>>> [a for a in dir(list) if not a.startswith('__')]

不要期待在原位置修改对象的函数会返回结果。像list.append、list.sort方法这样的原位置修改运算，并不会有返回值（除了None）。

字典keys方法返回的是试图而不是列表。

# 函数基础

**函数**就是将一些语句集合在一起的组件，从而让它们能够不止一次地在程序中运行（可以通过它们的名字来使用它们的打包的过程）。

## 函数相关的语句和表达式

语句或表达式            示例
调用表达式             myfuc("spam", "eggs", meat=ham, *rest)
def                   def printer(message):\ print('Hello' + message)
return                def adder(a, b=1,*c):\ return a+b+c[0]
global                x = 'old'\ def changer():\ global x; x = 'new'
nonlocal              def outer():\ x = 'old'\ def changer():\ nonlocal x; x = 'new'
yield                 def squares(x):\ for i in range(x): yield i**2
lambda                funcs = [lambda x: x**2, lambda x: x**3]

函数主要扮演两个角色：一是最大化代码重用和最小化代码冗余；二是过程分解。独立地实现较小的任务要比一次完成整个过程要容易得多。

def是可执行的代码。Python的函数是由一条新语句编写的，即def。可以将def理解成一条"="赋值语句：它在运行时给一个变量名赋值。

def创建了一个对象并将其赋值给某一变量名。当Python运行到def语句是，将生成一个新的函数对象并将其赋值给这个函数名。和所有的赋值一样，函数名变成了一个函数对象的引用。

lambda创建一个对象并将其作为结果返回。也可以用lambda表达式创建函数，这一功能允许我们把函数定义内联到语法上def语句不能工作的地方。

return将一个结果对象传回给调用者。

yield向调用者发回一个结果对象，但是回记住它离开的位置。

global声明了一个模块级的可被赋值的变量。变量名会在它的作用域也就是变量存储的地方被找到，而变量名与作用域的绑定是由实赋值语句实现的。

nonlocal声明了一个需要被赋值的外层函数变量。

参数是通过赋值（对象引用）传递给函数的。

除非你显式指明形式参数与实际参数的对应，否则实际参数按位置赋值给形式参数。通过*pargs和**kargs参数形式可以接收任意数量的实际参数。

参数、返回值与变量不需要被声明。

函数名并没有什么特别之处，关键在函数名所引用的那个对象：
>>> othername = func
>>> othername()
这里函数被赋值给一个不同的变量名，并通过新的变量名进行了调用。函数不过是对象，它们在程序运行时被明确地记录在内存中。实际上，除了调用外，函数允许将任意属性附加到其中以供之后使用：
>>> def func():
>>> func()
>>> func.attr = value

Python中的多态：
表达式x*y的意义完全取决于x和y的对象类型。实际上，*作为一个分派机制，将执行的控制权移交给被处理的对象。这种依赖类型的行为称为多态。只要对象支持所预期的接口（也称为协议），函数就能处理它们。从宏观上说，我们在Python中为对象接口编程，而不是数据类型。

# 作用域

Python创建、改变或查找变量名都是在所谓的命名空间（变量名存在的地方）进行的。

Python中一切与变量名有关的事件（包括作用域的分类），都发生在赋值的时候。

由于变量名最初没有声明，Python将一个变量名被赋值的地点关联为（绑定给）一个特定的命名空间，也就是它的可见范围。

变量可以在3个不同的地方被赋值，分别对应3种不同的作用域：

- 如果一个变量在def内赋值，它对于该函数而言是局部的。
- 如果在一个外层的def中赋值，对于内层的函数来说，它是非局部nonlocal的。
- 如果在所有def外赋值，它对于整个文件来说是全局的。

在开始编写函数之前，我们先前编写的所有代码都位于模块的顶层（也就是说，没有嵌套在def内），所以我们使用的名称要么存在于模块文件本身，要么就是Python预先定义好的内置名称。

从技术上讲，交互式命令行是一个名为__main__的模块，它可以打印结果，但不会保存其代码；在其他方面，它都与模块文件的顶层相同。

函数定义个局部作用域，而模块定义了具有如下属性的全局作用域：

- 外围模块是全局作用域。每一个模块都是一个全局作用域，也就是一个创建于模块文件顶层的变量的命名空间。模块被导入后，相对外部世界而言全局变量就成了模块对象的属性，但是在这个模块文件自身中也能像简单变量一样使用全局变量。
- 全局作用域的作用范围仅限于单个文件。别被这里的“全局”所迷惑，这里的全局指的是一个文件的顶层的变量名仅对于这个而文件内部的代码而言是全局的。在Python中是没有一个跨文件的单一且无所不包的全局作用域概念的。相反，变量名被划分到一个个模块中，并且你必须明确地导入一个模块文件才能使用这个文件中定义的变量名。当你在Python中听到“全局”时，你就应该联想到“模块”。
- 赋值的变量名除非被声明为global或nonlocal，否则均为局部变量。
- 所有其他的变量名都是外层函数的局部变量、全局变量或内置变量。
- 函数的每次调用都会创建一个新的局部作用域。每一条def语句（以及lambda表达式）都定义了一个新的局部作用域，局部作用域实际上对应于一次函数调用。

一个函数内部任何类型的赋值都会把一个名称划定为局部的。这包括=语句、import中的模块名、def中的函数名、函数形式参数名等。相反，原位置改变对象并不会把变量划分为局部变量，只有对变量名赋值才可以。

## 变量名解析：LEGB规则

变量名引用至多在四种作用域内进行查找：首先是局部（Local），其次是外层的函数（External），之后是全局（Global），最后是内置（Build-in）。

**内置作用域**仅仅是一个名为builtins的内置模块，但是必须导入builtins之后才能使用内置作用域，因为名称builtins本身没有预先内置。

global语句告诉Python函数计划生成一个或多个全局变量名，也就是说，存在于整个模块内部作用域的变量名。

模块的一个要点：通过在文件的层次上隔离变量，它们避免了跨文件的名称冲突，这与局部变量避免跨函数的名称冲突的方式很想。一个模块文件的全局作用域一旦被导入就成了这个模块对象的一个属性命名空间：导入者自动得到这个被导入的模块文件的所有全局变量的访问权，因为在一个文件被导入后，它的全局作用域就转变为一个对象的属性命名空间。

文件间进行通信的最好办法就是通过调用函数，传递参数，然后得到其返回值。

嵌套的作用域对应于程序源代码文本中物理上和句法上的嵌套代码结构。

## 工厂函数：闭包

**闭包（closure）**也叫工厂函数（factory function），能够记忆外层作用域里的值，不管那些嵌套作用域是否还在内存中存在。
>>> def maker(N):
      def action(X):
        return X**N
      return action
>>> f = maker(2)
>>> f
<function maker.<locals>.action at 0x0000000002A4A158>
>>> f(3)
9
>>> g = maker(3)
>>> g(4)
64
>>> f(4)
16
这定义了一个外层函数，用来简单生成并返回一个嵌套的函数，却并不调用这个内嵌的函数：maker创造出action，但知识简单地返回action而不执行它。如果调用外部的函数，我们得到的是生成的内嵌函数的一个引用。
这里最不平常的一点是，虽然在调用action时maker已经返回了值并退出，但是内嵌的函数记住了整数2，即maker内部的函数N的值。实际上，在外层嵌套局部作用域内的N被作为执行的状态信息保留了下来，并附加到生成action函数上，这也是当他稍后被调用是我们返回其参数平方的原因。每次对这样一个工厂函数的调用，都将得到属于调用自己的状态信息的集合。

lambda是个表达式，生成之后会调用的一个形函数，与def很相似。不过由于它是一个表达式，因此能用在def不能使用的地方。

nonlocal的作用域查找被限定在外层的def中。当执行一条nonlocal语句时，nonlocal名称必须已经在一个外层def作用域中被赋值过，也就是说，你不能通过赋值动态地在外层作用域中创建一个新的nonlocal名称。global可以在内层中创建全局变量。

# 参数

函数传递参数时的一些关键点：

- 参数的传递是通过自动将对象赋值给局部变量名来实现的。函数参数在实际中只不过是Python赋值的又一例子而已。因为引用是以指针的形式实现的，所有的参数实际上都是通过指针传入的。作为参数被传递的对象从来不会自动复制。
- 在函数内部赋值参数名不会影响调用者。在函数运行时，函数头部的参数名是一个新的、局部的变量名，这个变量名是在函数的局部作用域内的。
- 改变函数的可变对象参数的值也许会对调用者有影响。因为是直接把传入的对象赋值给参数，函数能够原位置改变传入的可变对象，因此结果可能会影响调用者。
- 不可变参数本质上传入了“值”。
- 可变对象本质上传入了“指针”。

return能返回任意种类的对象，所以它也能返回多个值，做法是将这些值封装进一个元组或其他的集合类型中。

## 特殊的参数匹配模式

你可以通过形式参数名、提供默认的参数值以及对额外参数使用容器等三种方法来制定匹配。

匹配模式大纲：

- 位置次序：从左至右进行匹配。
- 关键字参数：通过参数名进行匹配。
- 默认值参数：为没有传入值的可选参数制定参数值。
- 可变长参数（Varargs）收集：收集任意多的基于位置或关键字的参数。函数能够用一个*或两个**开头的特殊参数，来收集任意多的额外参数。
- 可变长参数解包：传入任意多的基于位置或关键字的参数。调用者也能使用*语法去将参数集合解包称单个参数。这个*与函数头部的*恰恰相反；在函数头部的*意味着搜集任意多的参数，而在调用者中意味着解包任意多的参数并将它们作为离散的值单独传入。
- keyword-only参数：必须按照名称传递的参数。

Python要求你所编写的参数匹配模式可选部分遵循以下规则：

- 在函数调用时，参数必须按此顺序出现：所有基于位置的参数（value），之后是所有关键字参数（name=value）和*iterable形式的组合，之后是**dict形式。
- 在函数头部，参数必须按此顺序出现：所有一般参数(name)，之后是所有默认值参数(name=value)，之后是*name形式，之后是所有name或name=value的keyword-only参数，之后是**name形式。

Python内部使用以下步骤在赋值前匹配参数：

1. 通过位置分配无关键字参数。
2. 通过匹配名称分配关键字参数。
3. 将剩下的非关键字参数分配到*name元组中。
4. 将剩下的关键字参数分配到**name字典中。
5. 把默认值分配给头部未得到匹配的参数。
在此之后，Python会检查以确保每个参数只被传入了一个值。如果不是这样，将引发一个错误。

函数头部中的参数名称还可以有一个注解值，其形式为name：value。函数自身也可以有一个注解值，以def f()->value的形式给出。

注意，如果你讲一个默认值参数编写为一个可变对象(例如，def f(a=[]))，同一个可变对象会在函数的所有调用中被反复地使用。最终的而效果是这个参数会默认从上一次调用中继续持有它的值，而不是重置为在def头部定义的原始值。为了每次都重置一个新的值，你需要把赋值语句移到函数的函数体中。可变默认值参数允许状态记忆，但这通常违背直觉。

在函数定义中把不能匹配的基于位置的参数搜集到一个元组中：
>>> def f(*args):print(args)
>>> f()
()
>>> f(1)
(1,)

**特性与之类似，但是它只对关键字参数有效。
>>> def (**args):print(args)
>>> f()
{}
>>> f(a=1,b=2)
{'a':1,'b'=2}

在调用时的*pargs形式是一个迭代上下文，因此从技术上讲它接受所有的可迭代对象，而不仅仅是元组或其他序列。

特殊的“可变长参数”调用的真正强大之处在于，在编写一段脚本之前不需要知道一个函数调用需要多少参数。
>>> def tracer(func, *pargs, **kargs):
      print('calling:', func.**name**)
return func(*pargs,**kargs)
    def func(a,b,c,d):
      return a+b+c+d
    print(tracer(func,1,2,c=3,d=4))

keyword-only参数编写为出现在参数列表中*args之后的有名参数。
>>> def kwonly(a,*b,c):
      print(a,b,c)
>>> kwonly(1,2,c=3)

- 上式c必须通过关键字参数进行赋值。

keyword-only参数必须编写在*args之后，**args之前。

keyword-only参数让一个函数既接受任意多个要处理的基于位置参数又接受作为关键字传入的配置项这件事变得容易。

内置版本的函数工作起来基本上与我们自己编写的函数一样，不过处于优化运行速度的目的采用C语言编写。

# 函数的高级话题

之所以使用函数，部分是由于函数的接口。

如何将任务分解成更为有针对性的函数（内聚性）、函数将如何通信（耦合性）。

函数设计原则：

- 耦合性：在输入时使用参数，输出时使用return语句。
- 耦合性：只在真正必要的情况下使用全局变量。
- 耦合性：不要改变可变类型的参数，除非调用者希望这样做。
- 内聚性：每一个函数都应该有一个单一的、统一的目标。
- 大小：每一个函数应该相对较小。
- 耦合性：避免直接改变其他模块文件中的变量。
- 通常，应该尽可能把函数和其他编程组件对外部的依赖性最小化。函数的自包含性越好，它就越容易被理解、复用和修改。

在几乎所有情况下，递归在内存空间和执行时间方面都较使用循环效率低。但递归能够遍历任意形状的结构。

在内部，Python通过在每一次递归调用时把信息压入调用栈来实现递归。

标准Python限制了运行时调用栈的深度，为扩大这一上限，可以使用sys模块：
>>> sys.getrecursionlimit()
1000
>>> sys.setrecursionlimit(10000)

递归式一种强大的工具，但只有在你理解并掌控它的时候才能发挥出巨大的威力。

Python中的函数是不折不扣的对象，其本身全部存储在内存块中。

函数对象支持一个特殊操作：它们可以由一个函数表达式后面的括号中的列表参数调用。

def语句中的名称并没有什么特殊含义：它知识当前作用域中的一个变量赋值，就好像它出现在=符号的左边一样。在def运行之后，函数名仅仅是一个对象的引用——我们可以自由地把这个对象赋值给其他的名称并且通过任何引用来调用它。

## 匿名函数：lambda

除了def语句之外，Python还提供了一种生成函数对象的表达式形式lambda。与def一样，这个表达式创建了一个之后能调用的函数，但是它返回该函数本身而不是将其赋值给一个变量。
lambda的一般形式： lambda argument1,argument2...argumentN: expression using argtuments
可以这样理解lambda，冒号（：）前是参数列表，冒号后是个表达式（return）语句。

- lambda是一个表达式，而不是语句。因此可以出现在def不允许出现的地方。
- lambda的主体是一个单独的表达式，而不是一个代码块。

默认参数也能在lambda参数中使用：
>>> x = (lambda a='fee',b='fie',c='foe': a+b+c)
>>> x('wee')
'weefiefoe'

lambda经常用来编写跳转表：
>>> L = [lambda x: x**2,
         lambda x: x**3,
         lambda x: x**4]
>>> for f in L:
      print(f(2))
    print(L[2](3))
  
print是一个调用表达式，而不是语句。表达式返回一个“值”，语句是过程控制流。

## 函数式编程工具

Python混合支持多种编程范式：过程式（使用基础的语句），面向对象式（使用类）和函数式。

Python提供了一整套进行函数式编程的内置工具，它们把函数作用于序列和其他可迭代对象。包括在一个可迭代对象的各项上嗲用函数的工具（map），使用一个测试函数来过滤项的工具（filter），还有把函数作用在成对的项上来运行结果的工具（reduce）。

- 可迭代对象上映射函数：map
map函数将被传入的函数作用到一个可迭代对象的每一个元素上，并返回包含了所有这些函数调用结果的一个列表。

>>> counters = [1,2,3,4]
>>> def inc(x): return x+10
>>> list(map(inc, conters))
[11,12,13,14]

- 选择可迭代对象中的元素：filter
filter和reduce分别实现了给予一个测试函数选择可迭代对象的元素，以及向“元素对”应用函数的功能。

>>> list(range(-5,5))
[-5,-4,-3,-2,-1,0,1,2,3,4]
>>> list(filter((lambda x: x>0),range(-5,5)))

- 合并可迭代对象中的元素：reduce
函数式reduce调用接受并处理一个迭代器，但它本身不是一个可迭代对象，它会返回一个单独的结果。

>>> from functools import reduce
>>> reduce((lambda x,y:x+y),[1,2,3,4])
10
>>> reduce((lambda x,y:x*y),[1,2,3,4])
24

# 推导和生成

列表推导将任意一个表达式而不是一个函数应用于一个迭代对象中的元素。

**标准推导语法**
在最简单的形式下，必须编写一个增量表达式和一个单独的for分句：

- [expression for target in iterable]
通过列表推导结构：
- [expression for target1 in iterable1 if condition1
              for target2 in iterable2 if condition2
              for targetN in iterableN if conditionN]

>>> res = [x+y for x in [0,1,2] for y in [100,200,300]]
>>> res
[100,200,300,101,201,301,102,202,302]

map函数和列表推导的最大区别是：map是一个可迭代对象，按需产生结果；为了达到同样的内存节省和运行时间加快，列表推导必须编写为生成器表达式。

让用户定义的操作推迟产生结果：

1. 生成器函数：使用常规的def语句进行编写，但是使用yield语句一次返回一个结果，在每次结果产生之间挂起和恢复他们的状态。
2. 生成器表达式：类似列表推导，但它们返回按需产生结果的一个对象，而不是创建一个结果列表。

生成器在适当情况下是一种很强大的工具。

可以传回一个值并随后从其挂起的地方继续的函数叫**生成器函数**，因为他们随着时间产生一系列的值。

当创建时，生成器函数被编译成一个支持迭代协议的对象，并在调用的时候他们不返回一个结果：他们返回一个可以出现在任何迭代上下文中的结果生成器。

生成器函数和常规函数之间主要的代码不同之处在于，生成器函数产生（yield）一个值，而不是返回（return）一个值。

生成器对象的__next__方法可以开始生成器函数，或者从它上次yield值后的地方恢复，并且在得到一系列值的最后一个时，引发StopIteration异常。

为了支持迭代协议，函数必须包含一条yield语句，该函数将被特别编译为生成器：它们不再是普通函数，而是作为通过特定的迭代协议方法来返回对象的函数。当调用时，它们返回一个生成器对象，该对象支持用一个自动创建的名为__next__的方法接口，来开始或恢复执行。生成器函数也可以有一条return语句，不过总是出现在def语句块的末尾，用于终止值的生成。从调用者的角度看，生成器的__next__方法将恢复函数执行并且运行到下一个yield结果的传回或引发一个StopIteration异常。最终效果就是生成器函数，被编写为包含yield语句的def语句，能自动地支持迭代协议，并且可以用在任何迭代上下文中以随时间根据需要产生结果。
>>> def gensquare(N):
      for i in range(N):
        yield i**2
>>> x = gensquares(4)
>>> x
<generator object gensquares at 0x00000000292CA68>
>>> next(x)
0

生成器函数协议中的send方法，生成一系列结果的下一个元素，这一点像__next__方法，但它也提供了一种调用者与生成器之间进行通信的方式，从能而影响生成器的操作。

从技术上来讲，yield现在是一个表达式，不是一条语句，它会返回发送给send函数的元素。当使用这一额外的协议时，值可以通过调用G.send(value)发送给一个生成器G，之后恢复生成器代码的执行，并且生成器中的yield表达式返回发送给send函数的值。如果调用了正常的G.__next__方法，则yield返回None。
>>> def gen():
      for i in range(10):
        x = yield i
        print(x)
>>> G = gen()
>>> next(G)
0
>>> G.send(77)
77
1
>>> G.send(88)
88
2
>>> next(G)
None
3

**生成器表达式**从语法上将跟一般的列表推导一样，但它们包括在圆括号而不是方括号中（跟元组一样，它们的圆括号是可选的）。
>>> [x**2 for x in range(4)]
[0,1,4,9]
>>> (x**2 for x in range(4))
<generator object <genexpr> at 0x0000000029A8288>

就像生成器函数，生成器表达式是一种对内存空间的优化：它们不需要像方括号的列表推导一样，一次构造出整个结果列表。另一方面，生成器表达式在实际中运行起来可能比列表推导稍慢一些，所以它们可能只对那些结果集合非常大的运算或者不能等待全部数据产生的应用来说是最优选择。

生成器函数：
一个使用了yield表达式的def语句是一个生成器函数。当被调用时，它返回一个新的生成器对象，该对象能自动保存局部作用域和代码执行位置；一个自动创建的__iter__方法能够返回自身；一个自动创建的__next__方法用于启动函数或从上次推出的地方继续执行，并在结果产生结束的时候引发StopIteration异常。
生成器表达式：
一个包括在圆括号中的列表推导表达式被称为一个生成器表达式。当它运行时，会返回一个新的生成器对象，这个对象带有同样是被自动创建的方法的接口和状态保持，一同作为生成器函数调用的结果——包括一个返回自身__iter__方法和一个启动隐式循环或从上次离开的地方重新开始的__next__方法，并且在结束产生结果的时候引发StopIteration异常。
最终结果是，两者都可以在能主动调用这些接口的迭代上下文中自动按需产生结果。

生成器是单遍迭代器。

生成器函数和
生成器表达式自身都是迭代器，并因此只支持一次活跃迭代。我们不能拥有在结果集中位于不同位置的多个迭代器。

yield from扩展：
>>> def both(N):
      yield from range(N)
      yield from (x**2 for x in range(N))
>>> list(both(5))
[0,1,2,3,4,0,1,4,9,16]

字典是在每次迭代中产生键的可迭代对象：
>>> D = {'a':1,'b'=2,'c':3}
>>> x = iter(D)
>>> next(x)
'c'
>>> next(x)
'b'

## 所有可能推导方式

>>> [x*x for x in range(10)]
[0,1,4,9,16,25,36,49,64,81]
>>> (x*x for x in range(10))
<generator objext at 0x009E7328>
>>> {x*x for x in range(10)}
{0,1,4,81,64,9,16,49,25,36}
>>> {x: x*x for x in range(10)}
{0:0,1:1,2:4,3:9,4:16,5:25,6:36,7:49,8:64,9:81}

# 基准测试

从性能上讲，列表推导有时比for循环有速度方面的优势，而且map调用会依据调用模式的不同比这两者更快或更慢。生成器函数和生成器表达式虽然比列表推导速度稍慢一些，但是它们不仅把内存需求降低到最小，还不会延迟结果的生成。

函数调用花费时间计算：
>>> import time
    def timer(func, *args):
      start = time.clock()
      for i in range(1000):
        func(*args)
      return time.clock() - start
>>> timer(pow, 2, 1000)
>>> timer(str.upper, 'spam')
> 上述计时器存在局限，包括：在被测试函数调用中不支持关键字参数；硬编码了重复次数；额外计入了range的时间开销；总使用time.clock，在Windows系统以外并非是最好的；无法让调用者检测待测函数确实有效；只给出总时间，在一些重负载的机器上可能会波动。

新的perf_counter和process_time函数有着定义良好和平台无关的语义：

- time.perf_counter()以包含小数部分的秒数返回一个性能计数器的值，其被定义为测量较短事件段所能使用的最高可用分辨率时钟。它包括在睡眠期间流逝的时间，而且是系统范围的。
- time.process_time()以包含小数部分的秒数返回当前进程中系统和用户CPU执行时间之和的值。它不包括睡眠期间流逝的时间，而且被定义为进程范围的。

要注意对于一般的简单函数而言，计时器代码本身的运行时间与被测时间处于同一量级，因此你不必对计时器结果过于较真。

timeit模块自动化了代码计时，支持命令行使用模式，并巧妙处理了一些平台相关的问题。profile标准库模块，提供了一套完整的源代码分析器工具。
>>> import timeit
    min(timeit.repeat(stmt="[x**2 for x in range(1000)]", number=1000,repeat=5)) # 重复5次，取最短运行时间
    timeit.timeit(stmt='[x**2 for x in range(1000)]', number=1000)  # Total time
    timeit.Timer(stmt='[x**2 for x in range(1000)]').timeit(1000) # Class API
    timeit.repeat(stmt='[x**2 for x in range(1000)]',number=1000,repeat=3)

通常，目前较大的速度瓶颈来自函数，无论他们是否是内置的。

Python是在编译def代码时静态检测Python的局部变量的，而不是在运行时通过发现赋值语句进行检测的。

任何在函数体内的赋值都会使相应的变量成为局部变量。import、=、嵌套def、嵌套类等，都会受这种行为的影响。产生这种文体的原因是被赋值的变量名在函数内部的所有位置都被当作局部变量来对待的，而不是仅仅在赋值以后的语句中才被当作是局部变量。

在函数中，不可能把一个简单变量名同时作为局部变量和全局变量。如果你真希望打印全局变量，并在之后设置一个有着相同变量名的局部变量，那么你需要导入外围的模块，并使用模块的属性标记来获得其全局变量。

当def语句运行的时候，默认值参数就被求值并保存，而不是在每次该函数被调用的时候。从内部来讲，Python会将每一个默认参数保存称一个对象，并附加到这个函数本身。以为默认值参数是在def时被求值的，如果需要的话，它能让你在外层作用域中保存值。但因为默认值参数在调用之间持有着同一个对象，你必须非常小心对可变默认值参数的修改。
>>> def saver(x=[]):
      x.append(1)
      print(x)
>>> saver([2])
[2,1]
>>> saver()
[1]
>>> saver()
[1,1]

Python中没有return语句的函数等价于一些其他语言中的“过程”。它们常被用作语句使用，并且一般忽略None这个返回结果，就好像它们只是执行任务而不需要计算有用的结果一样。

外层作用域和循环变量：工厂函数。当编写工厂函数时，要小心地使用外层函数作用域中对被外层作用域修改的变量的查找——当一个生成的函数之后被调用时，所有这些引用都会记住在外层函数作用域中最后一次循环迭代的值。在此情况下，你必须使用默认值参数来保存循环变量的值，而不是依赖于在外层作用域中自动查找。

# 模块：宏伟蓝图

模块是最高级别的程序组织单元。从实际的角度看，模块往往对应于Python程序文件。每一个文件都是一个模块，并且模块在导入其他模块之后就可以使用被导入模块中定义的名称。模块也可以是使用如C、Java等语言编写的扩展包，甚至可以在包导入时的文件路径。

import：使用户程序以一个整体获取一个模块。
from：允许用户程序从一个模块文件中获取特定的名称。
imp.reload：提供一种不在终止Python程序的情况下重新载入模块文件代码的方法。

模块和类实际上就是两种增强后的命名空间。

模块是提供自包含的变量的包（也就是所谓的命名空间）从而将部件组织为系统的一种可行方式。在模块导入时，模块文件的全局作用域变成了模块对象的属性命名空间。

模块扮演三个角色：

1. 代码重用。
2. 系统命名空间的划分。
3. 实现共享的服务和数据。

## Python程序架构

从本质上讲，一个python程序包括了多个含有python语句的文本文件。程序拥有一个主体的顶层文件，辅以零个或多个被称为模块的支持文件。一个程序是由一系列模块组成的系统。它有一个顶层脚本文件（用于启动并运行该程序）以及多个模块文件（用来导入工具库）。脚本和模块都是包含了Python语句的文本文件，尽管在模块中的语句通常都是创建之后使用的对象。Python的标准库提供了一系列的预先编写好的模块。

**模块的工作原理**：顶层文件（又称为脚本）包含了程序的主要控制流程。这就是你用来启动应用程序的文件。而模块文件是工具库，这些文件中收集了顶层文件（或者其他可能的地方）要使用的组件。顶层文件使用了在模块文件中定义的工具，而这些模块又有可能使用了其他模块所定义的工具。

尽管模块文件也是代码文件，但它们通常在运行时不需直接做任何事。作为替代，它们定义的工具会在其他文件中使用。在Python中，一个文件通过导入一个模块来获得这个模块定义的工具的访问权，这些工具被认为是这个模块的属性（即附加到模块对象的名称，例如函数）。总而言之，我们导入了模块、获取它的属性从而使用其中的工具。

import语句的实际效果是，将模块名（可以简单地认为是变量名）赋值了载入的模块对象。

在import执行时，import原则上会逐行运行在目标文档中的语句从而构建其中的对象。与此同时，每个在文件顶层赋值的名称都变成了模块的一个属性，这些属性可以被导入者访问。关于模块b的代码b.spam可以理解为：取出存储对象b中名称为spam的值。

代入是Python中程序结构的核心。导入是运行时的操作，第一次导入指定文件时，会执行三个步骤：

1. 找到模块文件。
2. 编译成字节码。Python会同时检查文件最近一次的修改事件和生成的字节码对应的Python版本号，从而决定接下来的行为。如果发现字节码文件比源代码文件旧，就在程序运行时重新生成字节代码。如果你的模块已加载后还需要再次导入，那么就要通过调用imp.reload函数来强制处理这个问题。
3. 执行模块代码来创建其所定义的对象。

> Python把载入的模块存储到一个名为sys.modules的表中，并在每次导入操作的开始首先检查该表。如果模块不存在，则启动这个三个步骤的过程。
> 只有被导入的文件才会在机器上留下.pyc文件。顶层文件的字节码是在内部使用后就丢弃了的；被导入文件的字节码则保存在文件中从而可以提高之后导入的速度。

Python的模块搜索路径是下面这些主要组件拼接而成的结果：

1. 程序的主目录（自动的）。当你运行一个程序的时候，主目录就是包含程序的顶层脚本文件的目录。当在交互式命令行下工作时，主目录就是你当前工作的目录。
2. PYTHONPATH目录（可配置的）。简而言之，PYTHONPATH是设置包含Python程序文件的目录列表，这些目录可以是拥护定义的活平台特定的目录名。
3. 标准库目录（自动的）。
4. 任何.pth文件中的内容（可配置的）。Python有个相对不常用的功能，允许用户把需要的目录添加到模块搜索路径中去，也就是在后缀名为.pth（路径path的意思）的文本文件中一行一行地列出目录。实际上，Python将收集它所找到的所有.pth路径文件中的目录名，并且会过滤掉任何重复的和不存在的目录。
5. 第三方扩展应用的Lib\site-packages主目录（自动的）。Python会自动将标准库的site-packages子目录添加到模块搜索路径。按照惯例，这是大多数第三方扩展安装的地方。

> 最终，这五个组件组合起来就变成了sys.path。所有这些的最终效果的，作为搜索路径构成部分的PYTHONPATH环境变量和.pth路径文件两者都允许我们定制导入查找文件的地方。

如果你想看看你的及其上实际的模块搜索路径配置，可以通过打印内置的sys.path列表，也就是标准库模块sys的path属性来查看这些路径。其实，sys.path就是模块搜索的路径。Python在程序启动时配置sys.path，自动将顶层文件的主目录（或者是在交互命令行模式下，代指当前工作目录的一个空字符串）、所有PYTHONPATH目录、已经创建的任何.pth文件路径的内容以及标准库目录合并。其结果是一个Python在每次导入新文件的时候查找目录名字符串的列表。

导入语句的本质是外部组件暴露的接口。具有import b形式的import语句可以加载或解析：

1. 源代码文件b.py
2. 字节码文件b.pyc
3. 优化字节码文件b.pyo
4. 目录b，对于包导入而言。
5. 编译扩展模块（通常c或c++编写），导入时使用动态链接（例如，Linux的b.so、Cygwin和Windows的b.dll或b.pyd）
6. 用c编写的编译好的内置模块，并被静态链接至Python
7. ZIP文件组件，导入时会自动解压缩。
8. 内存内镜像，对于冻结可执行文件而言。
9. Java类，在Jython版本中的Python中。
10. NET组件，在IronPython版本中的Python中。

导入和模块的意义就是为程序提供结构，让程序将其逻辑分割成一些独立完备的软件组件。

# 模块代码编写基础

模块怎么命名都可以，但是如果打算将其导入，模块文件名就应该以.py结尾。对于会执行但不会被导入的顶层文件而言，.py从技术上来讲是可有可无的，但加上去总是可以确保文件类型更醒目，并且可以在任何文件中被导入。

当一个模块被导入时，Python会把内部模块名映射到外部文件名，也就是通过把模块搜索路径中的目录路径加在前边，而.py或其他后缀名添加在后边。

from语句，把特定的名称从一个文件赋值到另一个作用域，所以它可以让我们直接在脚本中使用复制后的名称，而不需要通过模块。

from *语句，当我们用*代替特定的名称时，会取得模块顶层被赋值的所有名称的副本。

像def一样，import和from是可执行的语句，是隐式的赋值语句，而不是编译时的声明。import将整个模块对象赋值给一个单独的名称，from将一个或多个名称赋值给另一个模块中的同名对象

>>> from small import x,y # copy two names out
>>> x = 42
> 虽然这两个名字被copy到脚本模块命名空间，但这种赋值操作的结果，仍是可变对象，变量名是指向该对象的指针（对象并未copy到脚本模块）！
>>> import small # get module name
>>> small.x
> Python中所有赋值操作的工作原理都是一样的。

一种最佳的理解模块的方式是把它看作名称的封装，也就是你定义想让系统其余部分都能看见的名称的位置。简而言之，模块就是命名空间（名称所创建的位置），存在于一个模块内的名称被称为模块对象的属性。

在模块文件顶层赋值的所有名称都会成为该模块的属性。

1. 模块语句会在首次导入时执行。
2. 顶层的赋值语句会创建模块属性。
3. 模块的命名空间可以通过属性__dict__或dir(M)获取。
4. 模块是一个独立的作用域（局部变量就是全局变量）。模块顶层的名称遵循和函数内名称相同的引用/赋值规则，但局部作用域和全局作用域相同，遵循LEGB范围限制，但是没有L和E搜索层次。
模块全局作用域会在模块加载后变成模块对象的属性字典。和函数作用域不同的是，函数的局部命名空间只在函数执行时才存在，而模块文件的作用域在模块导入后就成为模块对象属性的命名空间，并在之后持续存在，从而为导入者提供了一个工具来源。

> 这里所谓模块导入后，其顶层变量变成全局变量的意思，就是创建后就持续存在。

命名空间字典：**dict**。在内部，模块命名空间被存储为字典对象。需要时，恶意通过模块的__dict__属性获取模块命名空间字典。
>>> list(models.**dict**.keys())
>>> module.name, modele.**dict**['name']

属性名称的点号运算：
> 点号运算其实就是表达式，它会返回和对象相关联的属性名的值。
> 点号运算是个独立的概念，和作用域法则没有关系。

Python获取指定名称的规则：

1. 简单变量：x是指当前作用域内搜索名称X，遵循LEGB规则。
2. 点号运算：x.y是指在当前作用域内搜索x，然后搜索对象x中的属性y，而非在作用域内。
3. 多层点号运算：x.y.z指的是在对象x中寻找名称y，然后再对象x.y中寻找名称z。
4. 通用性：点号运算可用于任何具有属性的对象：模块、类、C扩展类型等。

变量的意义一定是由源代码中赋值语句的位置决定的，而一个对象的属性总是被显式地获取。

- 函数绝对无法看见其他函数内的名称，除非它们从物理上处于这个函数内。
- 模块程序代码绝对无法看见其他模块内的名称，除非被显式地导入了。
这样的行为是词法作用域搜索概念的一部分：在Python中，一段代码的作用域完全由该代码在文件中所处的实际位置决定。

为什么要关注加载模块？为了动态定制化：reload函数允许在整体程序不停止的情况下修改程序的一部分。
reload在Python中是一个函数，而不是一条语句。
reload会在原位置修改模块对象。

所谓命名空间，不过是配对变量名和值的字典，不是一块实际的内存空间，**空间**两字具有误导性。

# 模块包

除了模块名之外，导入还可以指定目录路径。Python代码的目录被称为包，因此这样的导入就称为包导入。实际上，包导入是把计算机上的目录变成另一个Python命名空间，其属性则对应于目录中所包含的子目录和模块文件。

>>> import dir1.dir2.mod
语句中“带点号”的路径对应于机器上目录层次的路径，通过这个路径可以获得文件mod.py。也就是说，上面语句表明机器上有个目录dir1，而dir1有个子目录dir2，dir2内包含一个名为mod.py的模块文件。此外，这意味着dir1在某个**容器目录**dir0中，而dir0目录可以在Python模块搜索路径中找到。更严格地说，包导入路径中最左边的部分仍然是相对于sys.path模块搜索路径列表中的一个目录。

对于目录文件结构：dir0\dir1\dir2\mod.py
对应形式的import语句：import dir1.dir2.mod
遵循以下规则：

1. dir1和dir2中都必须含有一个__init__.py文件
2. dir0是容器文件，不需要__init__.py文件，如果有的话，也会被忽略
3. dir0必须列在模块搜索路径sys.path列表中

**init**.py可以包含Python程序代码，就像普通模块文件那样。它们的名字很特殊是因为它们的代码将在Python第一次导入一个路径的时候被自动运行，所以它们也被用作执行包的初始化步骤的钩子。

**init**.py文件可以用作包初始化的钩子，将目录声明称一个Python包，替目录生成一个模块命名空间以及在目录导入时实现from *语句行为的角色。

- 包的初始化。Python在首次导入某个目录时，会自动执行该目录下__init__.py文件中的所有程序代码。
- 模块使用的声明。报的__init__.py文件从某种程度上讲就是声明一个路径是Python包。
- 模块命名空间的初始化。在包导入的模型中，你脚本中的目录路径在导入后会变成真实的嵌套对象路径。**init**.py文件为目录创建的模块对象提供了命名空间。
- from *语句的行为。可以在__init__.py文件内定义__all__列表来规定目录以from* 语句形式导入时，需要导出什么。在__init__.py文件中，**all__列表是指当包（目录）名称使用from*的时候，应该导入的子模块的名称清单。如果没有设定__all**,from*语句不会自动加载嵌套于该目录内的子模块；取而代之的是，只加载该目录的__init__.py文件中赋值语句定义的名称，包括该文件程序代码显式导入的任何子模块。

**init**.py是当导入初次遍历一个包目录时所运行代码的文件，而类__init__构造函数方法是在创建一个实例对象时才调用的函数。

包让导入包含了更多信息，并可以作为组织工具来简化模块的搜索路径，同时还可以解决模糊性。包导入也可以大幅简化PYTHONPATH和.pth文件搜索路径设置。实际上，如果对所有跨目录的导入都使用包导入，并且让这些包导入都相对于一个共同的根目录，以及把所有Python程序代码都存在其中，那么在搜索路径上就只需一个单独的接入点：通用的根目录。最后，包导入能让你想导入的文件更明确，从而解决模糊性。同时还能解决同一模块在多处被导入所引发的冲突。

实际中，必须借助包导入的场景，就是解决当多个同名程序文件安装在同一个机器上时，所引发的模糊性。

Python搜索文件是现行的，总是从左到右扫描。

## 四种导入模型

1. 基础模块导入：import mod、from mod import attr。对文件及其内容的导入，相对于sys.path模块搜索路径。
2. 包导入：import dir1.dir2.mod、from dir1.mod import attr。相对于sys.path模块搜索路径的目录路径扩展。
3. 包相对导入：from . import mod(相对)、import mod(绝对)。
4. 命名空间包：import splitdir.mod。允许包横跨多个目录。它解决了一种在包的各部分进行合并时，存在多个__init__.py文件的潜在冲突，解决的方式是彻底移除这些文件。对于一些各个部分分散在多个不同目录下或未予多个sys.path项目中的包，命名空间包也能够为它们提供标准支持。同时命名空间包增强了安装的灵活性，并提供了一种通用的机制，从而替代多种为了达到同样目的互相之间不兼容的解决方案。

命名空间包导入算法：

1. 如果找到directory\spam\_*init*_.py，便会导入一个常规包并返回。
2. 如果找到directory\spam.{py.pyc,或其他模块扩展名}，便会导入一个简单模块并返回。
3. 如果找到文件夹directory\spam，便会将其记录下来，而扫描将从搜索路径中的下一个目录继续。
4. 如果上述的所有都没有找到，扫描将从搜索路径中的下一个目录继续。
如果搜索路径扫描结束后没有从上述1、2中返回一个模块或包，而同时在上述4中至少记录了一个路径，那么就会创建一个命名空间包。

最终的结果是一个命名空间包是一种多个目录的虚拟拼接，这些目录可以位于多个sys.path项目中。

# 高级模块话题

- 在Python中你总是位于某个模块内。即使在交互式命令行下输入的代码实际上也存在于一个名为__main__的内置模块中农。
- 最小化模块耦合：全局变量。除了主动导入的函数和类之外，模块应该尽可能地独立于其他模块内使用的全局变量。
- 最大化模块内聚：统一的目标。如果模块内所有组件都拥有一个共同的目标，你就不太可能依赖于外部名称。
- 模块应尽可能不去更改其他模块的变量。

在名称前面加上一个单独的下划线，可以防止客户程序使用from *语句导入模块名时，把这些加下划线的名称复制出来。

你也可以通过在模块顶层把变量名的字符串列表赋值给变量__all__，从而达到类似于_x命名惯例的隐藏效果。

每个模块都有一个名为__name__的内置属性。如果文件作为顶层程序文件执行，在启动时__name__就会被设置为字符串"**main**"。如果文件被导入，__name__就会被设成客户程序所了解的模块名。结果就是，模块可以检测自己的__name__来判断它是在执行还是在导入。
>>> if **name** == '**main**':
      somefunc()

Python程序本身也能够修改搜索路径，也就是搜索内置的sys.path列表。
>>> import sys
>>> sys.path
['','C:\\temp','C:\\windows\\system32\\python33.zip',...]
>>> sys.path.append('C:\\sourcedir')

因为模块通过内置属性的形式暴露了它们有用的性质，因此你可以容易地编写程序来管理其他程序。我们通常称这类管理程序为源程序（metaprogram），因为它们是在其他系统之上工作。这也成内省（introspection），因为程序能看见和处理对象的内部。
下列所有表达式都会得到相同的属性和对象：

1. M.name
2. M.**dict**['name']
3. sys.modules['M'].name
4. getattr(M,'name')
通过像这样暴露模块内部，Python能让你构建关于程序的程序。

- 在导入时，模块文件顶部的程序代码（不在函数内），在Python运行到的时候会立刻执行。
- 位于函数体内的代码直到函数被调用后才会运行。

from语句其实是在导入者的作用域内对名称赋值，也就是名称复制运算，不是名称的别名机制。

由于from语句只是将名称复制出来，所以from导入者不会被重载更新。

# OOP：宏伟蓝图

**类**是Python中一种新的对象，并支持继承的代码结构和部件。概括地讲，类就是一些函数的包，这些函数大量地使用并处理内置对象类型。

**OOP**（Object-Oriented Programing）提供了一种不同寻常而往往更有效的编程方式，利用这种涉及方法，我们将代码分解从而把冗余程度降至最低，并且通过定制已有的代码来编写新的程序而不是在原处进行修改。

程序就是“用一些东西来做事”，类就是一种定义新种类的东西的方式，它在程序领域中反映了现实中的对象。

由于妥善使用类需要一些预先的规划，因此相比于那些采用战术模式工作的人（时间有限），采用战略模式工作的人（做长期产品开发）对类会更感兴趣一些。

类的三个重要独特之处：

1. 多重实例。类本质上是产生对象的工厂。
2. 通过继承进行定制。类支持OOP的继承概念。
3. 运算符重载。通过提供特定的协议方法，类可以定义对象来响应在内置类型上的一些运算。

Python的OOP机制主要依托于两个基础：一个特殊的函数第一位参数（来接收调用主体）以及继承属性搜索（使编码支持定制化）。除此之外，这个模型基本上就是处理内置类型的函数。

## 属性继承搜索

Python中大多数OOP的故事，都可简化成这个表达式：object.attribute，即搜索attribute首次出现的地方，先搜索object，然后是该对象上的所有类，由下网上，由左到右。换句话说，属性访问知识搜索类树而已。

**类**是实例工厂，类的属性提供了行为（数据以及函数），所有从类产生的实例都继承了该类的属性。

**实例**代表程序领域中具体的元素，实例的属性记录了每个实例自己的数据。

事实上，面向对象模型与经典的过程加记录的数据处理模型相比，并没有太多的差异。在OOP中，实例就像是带有“数据”的记录，而类则是处理这些记录的“程序”。不过OOP中有继承层次的概念，这与以往的模型相比能更好地支持软件定制。

**类树**：
通常把树中位置较高的类称为父类（superclass）（比如C2和C3），树中位置较低的类则称为子类（subclass）（比如C1）。父类提供了子类共享的行为，但是因为搜索过程是自底向上的，所以子类可能会在树中较低位置重新定义父类的名称，从而覆盖父类定义的行为。

实例I2的属性引用I2.w，这个代码会触发对类树的搜索，也就是Python会查看I2和更高的对象来搜索属性w。如果在比如C3中找到了w，则I2.w会解析为C3.w。如果I2.w引用是个函数调用，其实际的含义是“调用C3.w函数来处理I2”，也就是说，Python会自动将I2.w()调用映射为C3.w(I2)调用，同时传入I2作为函数的第一位参数。

事实上，每当我们以这种方式调用附属于类的函数时，总会隐含着这个类的实例。这个隐含的主体或上下文就是将其称之为面向对象模型的一部分原因：当操作执行时，总是有个主体对象。

类的构造：

1. 每个class语句会生成一个新的类对象。
2. 每次类调用时，就会生成一个新的实例对象。
3. 实例自动链接到创建它们的类。
4. 类链接到其父类的方式是，将父类列在class头部的括号内；括号中从左到右的顺序会决定树中的次序。

OOP是关于代码重用的。类所支持的代码重用方式是Python其他程序组件难以提供的。代码重用也是它们最重要的目的。通过类，我们可以定制现有的软件来编写代码，而不是对现有代码进行在原处的修改或者对每个新项目都从头开始。这在实际编程中被证明是一种强大的范式。

**方法**知识有特殊第一位参数的函数。

**继承**的实现，源于自下而上的属性搜索机制。

**多态**是指运算的意义取决于运算的对象。也就是说，代码不应该关心它处理的对象是什么，而只应当关注这个对象应该做什么。

父类集合，就是**软件框架**（framework）。这些框架把常见的程序设计任务实现成类，以便你在应用程序中使用。

在OOP下写程序，所需要做的就是通过编写自己的子类，组合和定制已调试过的代码。

将常见的OOP结构归类，称为设计模式（design pattrern），来协助解决设计中的问题。

# 类代码编写基础

从最底层看，类基本上就是命名空间，但类和模块有三个主要不同之处，即支持生成多个对象，命名空间继承以及运算符重载。

Python的OOP模型中有两种对象：类对象和实例对象。**类对象**提供默认行为，是实例对象的工厂。**实例对象**是程序处理的实际对象：各自都有独立的命名空间，但是同时继承了创建该实例的类中的变量名。类对象来自语句，而实例来自调用。

Python类的主要特性：

1. class语句创建类对象并将其赋值给一个名称。
2. class语句内的赋值语句会创建类的属性。
3. 类属性提供了对象的状态和行为。

类的实例对象的主要特性：

1. 像函数那样调用类对象会创建新的实例对象。
2. 每个实例对象继承了类的属性并获得了自己的命名空间。
3. 在方法内对self属性做赋值运算会产生每个实例自己的属性。

所谓的Python继承：继承是在属性点号运算时发生的，而且只与查找连接对象内的名称有关。

属性继承机制的核心观点：

1. 父类列在class语句头部的括号中。
2. 类从其父类中继承属性。
3. 实例会继承所有可访问类的属性。
4. 每个object.attribute引用都会启动一个新的独立的搜索。
5. 逻辑的修改是通过创建子类，而不是修改父类。
这种搜索的最终结果和主要目的就是，类支持了程序的分解和定制，这比迄今为止所见到的其他所有语言工具都要好。

在树中较低处发生的通过重新定义取代属性的动作称为**重载**。

类是模块内的属性。

类可以截获Python运算符。
**运算符重载**就是让用类编写的对象，可以截获并响应在内置类型上的运算：加法、切片、打印和点号运算等。这其实是一种自动分发机制：表达式和其他内置运算被路由到了类内部的而实现。

重载运算符主要概念的概要：

1. 以双下划线命名的方法（**x**）是特殊钩子。在Python类中，实现运算法重载通过提供特殊命名的方法来拦截运算。Python语言在每种运算和特殊命名的方法之间，定义了固定不变的映射关系。
2. 当实例出现在内置运算中时，这类方法会自动被调用。例如，实例对象继承了一个__add__方法，那么当对象出现在+表达式内时，该方法就会被调用。而该方法的返回值将作为相应表达式的结果。
3. 类可以重载绝大多数内置类型运算。Python中有几十种特殊运算符重载的方法的名称，几乎可截获并实现内置类型的所有运算。
4. 默认的运算符重载方法既不存在，也不需要。如果类没有定义或继承运算符重载方法，那么类的实例将不能支持相应的运算。
5. 新式类有一些默认的运算符重载方法，但是不属于常见运算。
6. 运算符将类与Python的对象模型结合到一起。通过重载类型运算，我们可以让采用类实现的用户定义对象获得与内置对象一样的行为，因此保证了与预期接口的一致性和兼容性。

即使没有实例，类本身也是对象。事实上，类其实只是自包含的命名空间。

命名空间对象的属性通常都是以字典的形式实现的，而类继承树只是互相连接的字典而已。

__dict__属性是大多数基于类的对象的命名空间字典。这样一个属性既可以通过字典索引又可以通过属性记号访问，但是仅当其出现在所需的对象上。属性记号启动了继承搜索，但是索引只在单独的该对象中查看:
>>> x.name, x.**dict**['name']
('Sue','Sue')
>>> x.**dict**['age']
KeyError:'age'

每个实例都有一个Python帮我们创建好的指向其类的链接，**class**:
>>> x.**class**
<class '**main**.rec'>

类有一个__bases__属性，它是其父类对象引用的元组：
>>> rec.*bases*_
(<class 'object'>,)

Python的类模型是相当动态的。类和实例只是命名空间对象，它们所携带的属性是通过赋值语句动态创建的。所以，类的属性可以通过赋值语句事后添加。即使是方法，也可以完全独立地创建在任意类对象的外部。

在通常情况下，类是由calss语句填充的，而实例的属性则是在方法函数中通过对self属性进行赋值运算而穿件的。不过，重点在于并不是必须如此。Python中的OOP其实就只是在已连接命名空间的对象内寻找属性而已。

# 一个更加实际的示例

Python的类系统，其实很大程度上就是在一个对象树中查找属性，并为函数传入一个特殊的第一位参数。

1. 创建实例

创建构造函数
>>> class Person:
      def **init**(self,name,job=None,pay=0):
        self.name=name
        self.job=job
        self.pay=pay
在OO术语中，self就是新创建的实例对象，而name、job和pay则成为了状态信息，即保存在对象中供随后使用的描述性数据。
根据Python语法规则，一个函数定义中，在第一个拥有默认值的参数之后的所有参数，都必须拥有默认值。

2. 添加行为方法

封装的思想就是把操作逻辑包装到接口之后，这样每次操作在我们的程序里只会编写一次。

>>> class Person:
      def **init**(self, name,job=None,pay=0)
        self.name=name
        self.job=job
        self.pay=pay
      def giveRaise(self, percent):
        self.pay = int(self.pay*(1+percent))

3. 运算符重载

>>> class Person:
      def **init**(self, name,job=None,pay=0)
        self.name=name
        self.job=job
        self.pay=pay
      def giveRaise(self, percent):
        self.pay = int(self.pay*(1+percent))
      def **repr**(self):
        return '[Person: %s, %s]' % (self.name, self.pay)

4. 通过编写子类定制行为

每当你复制粘贴代码时，基本上都会使未来的维护工作倍增。最好能扩展父类的方法，而非完全重写。

>>> class Manager(Person):
      def giveRaise(self, percent, bonus=.10):
        Person.giveRaise(self,percent + bonus)

这段代码利用了这样一个事实：类方法总是可以在一个实例中调用(instance.method(args...))，或者通过类来调用(class.method(instance,args...))。

5. 定制构造函数

>>> class Manager(Person):
      def **init**(self,name,pay):
        Person.**init**(self,name,'mgr',pay)
      def giveRaise(self, percent, bonus=.10):
        Person.giveRaise(self,percent + bonus)
      def **getattr**(self, attr):
        return getattr(self.person, attr)
      def **repr**(self):
        return str(self.person)

- OOP机制的重要概念：
实例创建：填充实例属性。
行为方法：在类的方法中封装逻辑。
运算符重载：为像打印这样的内置操作提供行为。
定制行为：重新定义子类中的方法以使其特殊化。
定制构造函数：向父类的初始化步骤中添加逻辑。

此处的Manager替代方案是**委托设计模式**的一个典型代表。委托是一种基于组合的结构，它管理一个被包装在内部的对象并且把方法调用传入给它。

OOP强大的原因之一是，它能够对真实世界中的实体进行建模。

6. 使用内省工具

> 内省instraspection，即自我检查。Python的内省工具是程序自带的默认属性。

Python的内省工具允许我们访问对象实现的内部机制的一些特殊属性和函数。有两个钩子：

1. 内置的instance.**class__属性提供了一个从实例到创建它的类的链接。同时类有一个__name**，一个__bases__序列来提供父类的访问。
2. 内置的object.__dict__属性提供了一个字典，将所有命名空间对象（包括模块、类和实例）中的属性都存储为键/值对。

__repr__采用通用的内省工具来显示重载，它将会对任何实例有效：
>>> def **repr**(self):
      return '[%s:%s]' % (self.**class**.**name**,self.gatherAttrs())

因为这个类使用__repr__而不是__str__，所以它在所有的场景下都能使用。

7. 把对象存储到数据库中

对象持久化通过3个标准的库模块实现：

1. pickle：实现任意Python对象与字节串之间的序列化和解序列化。
2. dbm：实现一个通过键访问的文件系统，以存储字节串。
3. shelve：使用以上两个模块按照键把Python对象存储字节串。

pickle模块是一种非常通用的对象格式化和解格式化工具：对于内存中几乎所有的Python对象，它都能聪明地把对象转换为字节串，这个字节串可以随后用来在内存中重新构建最初的对象。

shelve模块提供了一层额外的结构，让你能按照键来存储pickle处理后的对象。

>>> from person import Person, Manager
    bob = Person('Bob Smith')

    import shelve
    db = shelve.open('persondb')
    for obj in (bob):
      db[obj.name] = obj
    db.close

# 类代码编写细节

就像def一样，**class语句**是对象的创建者并且是一个隐含的赋值运算：当它执行时会产生类对象，并把其引用值存储到前面所使用的名称中。

>>> class ShareData:
      spam = 42
    x = ShareData()
    y = ShareData()
    ShareData.spam = 99
    x.spam, y.spam, ShareData.spam
(99,99,99)

像这样的类属性可以用于管理横跨所有实例的信息。

对实例的属性进行赋值运算会在该实例内创建或修改名称，而不是在共享的类中。

下面两个方法是等价的：

- instance.method(args...)
- class.method(instance,args...)

在一个类方法中，第一位参数通常是self。这个参数给方法提供了一个钩子，从而返回调用的主体也就是实例对象：因为类可以产生很多实例对象，所以需要这个参数来管理每个实例彼此各不相同的数据。

class语句创建的命名空间的重点就是支持名称继承。在Python中，当对对象进行点号运算时就会触发继承，而且涉及了搜索属性定义树，即在一个或多个相互链接的命名空间中搜索。每次使用object.attr形式的表达式时，这里的object代表实例或类对象，Python会自底向上搜索命名空间树，先从该对象开始，寻找所能找到的第一个attr。这包括在方法中对self属性的引用。由于树中较低处的定义会屏蔽较高处的定义，因此继承成为定制化的基础。

属性树的构造：

1. 实例属性是由对方法内的self属性进行赋值运算而产生的。
2. 类属性是通过class语句内的赋值语句创建的。
3. 父类的连接是通过class语句首行的括号内列出的类而产生的。
结果就是连接实例的属性命名空间树，到产生它的类，再到类首行中所列出的所有父类。

重新定义继承名称的概念引出了各种定制化技术。例如，子类可以完全替代继承的属性、提供父类所预期的属性，以及在被覆盖的方法中调用父类方法来扩展父类方法。

类与模块一样也有特殊的__name__属性。默认是类头部行中的类名称字符串。

名称解析规则：

1. 无点号运算的名称（例如X）对应于作用域。
   赋值语句（X=value），在当前局部作用域内创建或改变名称X，除非使用global把它声明为全局的。
   引用（X），按照LEGB规则，先在当前作用域中搜索X，然后再所有外层函数中，再到当前全局作用域中，最后在内置作用域中。外层的类不会被搜索：相反，类名称是作为对象属性被访问。
2. 带点号的属性名（例如object.X）使用的是对象的命名空间。
   赋值语句（object.X=value），在进行点号运算的object命名空间内创建或修改属性名X，而没有其他作用。继承树的搜索值发生在属性引用时，而不是属性的赋值运算时。
   引用（object.X），对基于类的对象而言，会在object内搜索属性名X，然后是其上所有可访问的类（采用继承搜索过程）。对模块这样不是基于类的对象而言，则是直接从对象中访问X。
3. 有些作用域用于初始化对象的命名空间（用于模块和类）。

属性和变量一样，赋值后才会存在，而不是赋值前。

尽管类能够访问外层函数的作用域，但它们不能作为类中其他代码的外层作用域：Python搜索外层函数来访问被引用的名称，但从来不会搜索外层类。也就是说，类是一个可以访问其外层作用域的局部作用域，但其本身却不能作为一个外层作用域被访问。因为方法函数中对名称的搜索跳过了外层的类，所以类属性必须作为对象属性并使用继承来访问。

模块的命名空间具体被实现为字典，并将其暴露为内置的__dict__属性。类对象和实例对象也是如此，属性的点号操作在内部基本上就是字典的索引运算，而属性继承其实就是搜索链接的字典而已。实际上，在Python内部，实例对象和类对象就是相互之间带有链接的字典而已。

因为属性在Python内部实际上是字典键，所以其实有两种方式可以访问并对其进行赋值，即通过点号运算或者键索引运算：
>>> x.data1,x.**dict**['data1']
('spam','spam')
不过这种等效关系只适用于实际中附加在实例上的属性。因为属性的点号运算也会执行继承搜索，所以可以访问命名空间字典无法访问的继承属性。

# 运算符重载

**运算符重载**只是意味着在某个类的方法中拦截内置的操作——当类的实例出现在内置操作中时，Python会自动调用你的方法，并且你的方法的返回值会作为相应操作的结果。

重载背后的关键概念：

1. 运算符重载让类拦截常规的Python操作。
2. 类可以重载所有Python表达式运算符。
3. 类也可以重载打印、函数调用、属性访问等内置运算。
4. 重载使类实例的行为更接近内置类型。
5. 重载是通过在一个类中提供特殊名称的方法来实现的。

一个简单的重载例子：
>>> class Number:
      def **init**(self,start):
        self.data = start
      def **sub**(self, other):
        return Number(self.data - other)
>>> from number import Number
    X = Number(5)
    Y = X - 2
    Y.data
3

从技术角度来说，在一个实例被创建的过程中，首先出发的是__new__方法。这一方法将创建并返回一个新的实例对象，并传入__init__函数以供初始化。由于__new__方法拥有一个内置的实现，并且在重定义之后担任的角色非常有限，因此几乎所有的Python类通过定义__init__方法来初始化。

## 常见运算符重载方法

方法名      实现功能      触发调用的形式
**init**    构造函数      对象创建：X=Class(args)
**del**     析构函数      X对象回收
**add**     "+"运算符     X+Y,X+=Y（如果存在__iadd__，则"+="使用重载后的__iadd__）
**or**      "|"运算符（按位或） X|Y,X|=Y（如果存在__ior__，则"|="使用重载后的__ior__）
**repr**,**str**  打印、转换  print(X),repr(X),str(X)
**call**    函数调用      X(*args,**kargs)
**getattr** 属性访问      X.undfined
**setattr** 属性赋值      X.any = value
**delattr** 属性删除      del X.any
**getattribute**  属性访问  X.any
**getitem** 索引、分片、迭代  X[key]、X[i:j]、没有重载__iter__方法的for循环和其他迭代操作
**setitem** 索引赋值和分片赋值  X[key] = value、X[i:j] = iterable
**delitem** 索引删除和分片删除  del X[key]、del X[i:j]
**len**     长度        len(X)、没有重载__bool__方法的真值测试
**bool**    布尔测试      bool(X)、真值测试
**lt**,**gt**, 比较        X<Y,X>Y,X<=Y,X>=Y,X==Y,X!=Y
**le**,**ge**,
**eq**,**ne**
**radd**    右侧“+”操作   Other+X
**iadd**    原位置"+="操作  X+=Y
**iter**,**next**   迭代上下文  I=iter(X),next(I);for循环、没有重载__contains__方法的in操作、所有的推导表达式、map(F,x)、其他
**contains**  成员关系测试    item in X
**index**   整数值转换    hex(X),bin(X),oct(X),O[X],O[X:]
**enter**,**exit**  上下文管理器    with obj as var:
**get**,**set**,**delete**   描述符属性    X.attr,X.attr = value, del X.attr
**new**     创建    在__init__之前的对象创建

举点例子：

拦截分片
>>> class Indexer:
      data = [5,6,7]
      def **getitem**(self,index):
        print('getitem:', index)
        return self.data[index]
>>> x = Indexer()
>>> x[0]
getitem:0
5

当我们用类编写用户定义的可迭代对象时，由我们自己来决定是支持单个还是多个活跃迭代。要达到多个迭代器的效果，__iter__只需迭代器定义一个新的状态对象，而不是在每次迭代器请求中都返回self。
>>> class SkipObject:
    def **init**(self, wrapped):
      self.wrapped = wrapped
      def **iter**(self):
        return SkipIterator(self.wrapped) # new iterator each time
>>> class SkipIterator:
      def **init**(self, wrapped):
        self.wrapped = wrapped
        self.offset = 0
      def **next**(self):
        if self.offset >= len(self.wrapped):
          raise StopIteration
        else:
          item = self.wrapped[self.offset]
          self.offset += 2
          return item

当有__iter__时，迭代触发__iter__并返回一个新的带有__next__的生成器。
当没有__iter__时，你的代码会调用一个生成器并返回它自身作为__iter__。

__getattr__方法拦截属性引用。当你用一个未定义的属性名称字符串对一个实例对象做点号运算时，它就会被调用。如果Python通过其继承树搜索过程找到这个属性，那么该方法就不会被调用。

__setattr__会捕捉所有的属性赋值。准确来说，**setattr__会拦截对self的直接属性的赋值，但不会拦截对self的直接属性的修改，因此对__dict__的修改不会再次调用__setattr**。

捕获属性引用和赋值通常是很有用的技术。它支持委托：一种允许控制器对象包装内嵌对象，添加新的行为，并将其他操作传回内嵌对象的设计方案。

Python提供了两种显示方法来为不同的观众支持不同的现实。__str__会首先被打印操作和str内置函数尝试。它通常返回一个拥护友好的显示。__repr__用于所有其他场景：包括交互式命令行、repr函数、嵌套的显示，以及没有可用__str__时的print和str调用。

当调用实例时就会使用__call__方法。该方法支持所有的参数传递模式，传递给实例的所有信息都会传递给该方法。当需要适配期待函数的API（也就是库）接口时，__call__就变得非常有用：它既允许我们编写遵循函数调用接口的对象，又让我们能使用类的诸如状态信息记忆和继承关系等功能。

# 类的设计

封装意味着在Python中打包，也就是把实现的细节隐藏在对象接口之后。

**继承**是一种指明集合成员关系的方式：类定义了一个属性集合，可由更具体的集合（如子类）继承和定制。
>>> class Employee:
      def **init**(self,name,salary = 0):
        self.name = name
        self.salary = salary
>>> class Chef(Employee):
      def **init**(self,name):
        Employee.**init**(self,name,50000)

**组合**涉及把其他对象嵌入容器对象内，并促使其实现容器方法。组合不是集合的成员关系，而是组件，也就是整体的组成部分。
>>> class Customer:
      def **init**(self,name):
        self.name = name
      def order(self,server):
        print(self.name,"orders from",server)
>>> class Oven:
      def bake(self):
        print("oven bakes")
>>> class PizzaShop:
    def **init**(self):
      self.oven = Oven()
    def order(self,name):
      customer = Customer(name)

**托管**是指控制器对象内嵌其他对象，并把操作请求传递给那些内嵌的对象。托管是组合的一种特殊形式。它使用包装器（有时叫代理）类管理单一的内嵌对象，而包装器类则保留了内嵌对象的多数或全部的接口。
Python通常使用__getattr__方法钩子来实现委托。
>>> class Wrapper:
      def **init**(self,object):
        self.wrapped = object
      def **getattr**(self,attrname):
        print('Trace:'+attrname)
        return getattr(self.wrapped,attrname)
>>> x = Wrapper([1,2,3])
>>> x = x.append(4)
Trace:append
>>> x.wrapped
[1,2,3,4]
总的效果就是通过Wrapper类内的额外代码来扩充被包装对象的全部接口。

**名称重整**（mangling，相当于扩展），可以使类中的某些名称局部化。重整后的名称有时会被误认为是“私有属性”，但这其实只是一种把类所创建的名称局部化到这个类的方式而已：名称重整并不能够阻止来自类外部代码的访问。

名称重整的工作方式：只有在class语句内部，任意开头有双下划线，但结尾没有双下划线的名称，会自动在前面包围外围类的名称从而进行扩展。例如，Spam类中的__X会被自动扩展成_Spam__X。

伪私有属性解决的主要问题之一就是实例属性的存储方式。Python中所有实例属性最后都会位于类树底部的单个实例对象内，并被那些将该实例作为参数的类级别的方法函数共享。

Python程序员使用单个下划线来编写内部名称（例如_X）。

类的方法在Python中有两种形式：

1. 未绑定（类）方法对象：无self
   通过对类进行点号运算从而获取类的函数属性，会传回未绑定方法对象。调用该方法时，必须明确提供实例对象作为第一位参数。一个未绑定方法和一个简单函数是相同的。
2. 绑定（实例）方法对象：self+函数
   通过实例进行点号运算从而获取类的函数属性，会传回绑定方法对象。Python在绑定方法中自动把实例和函数打包，所以不用传递实例去调用该方法。

有时，基于类的设计需要创建对象，以应对程序编写时不能够预测的情况。工厂设计模式允许这样的延迟方式。

将类作为传入参数以生成其他种类对象的函数，被称为**工厂**。
>>> def factory(aClass,*pargs,**kargs):
      return aClass(*pargs,**kargs)
>>> class Person:
      def **init**(self,name,job=None):
        self.name = name
        self.job = job
>>> object = factory(Person,"Arthur","King")

这就是你在Python需要编写的唯一工厂函数，它对任意类和任意构造函数参数都有效。

这样的一个工厂可以允许代码与动态配置的对象构造细节相隔绝。

**多继承**，类和它的实例从列出的所有父类中继承名称。

1. 在经典类中，所有情形下的属性搜索始终实行深度优先搜索，直到继承树的顶端，然后从左至右进行。这一顺序称为DFLR(depth first, left to right)。
2. 在新式类中，属性搜索通常和之前是一样的，但在钻石模型下是以广度优先的方式进行，搜索在向上移动之前沿着继承树的同一级搜索。这一顺序称为MRO(method resolution order)。

多继承的主要缺点是，当相同的方法（或其他属性）名称在不止一个父类中定义时，就会造成冲突。

# 类的高级主题
