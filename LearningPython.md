---
output: pdf_document
---

Python学习手册

- Mark Lutz著， 秦鹤、林明译

> 该书的学习目标是：熟悉掌握Python语言本身。（2021-11-17）

# 前沿

**Python的类**基本上仅仅是处理内置类型函数的包。一旦你掌握了内置类型和函数，理解类就相对容易了。  
**函数**是打包代码并重用的一种简单方式，它避免了代码冗余。  
**Python模块**允许你将语句和函数组织为更大的组件。  
**类**一种可选但是强大的组织代码以便定制和重用的方式，使用它能自然地将代码冗余程度降到最低。  
现今的Python拥有内置类型、生成器、闭包、推导、Unicode、装饰器，以及过程式、面向对象及函数式编程范式的混合。

# 问答环节

> 本章介绍Python流行背后的一些主要原因。  

Python注重可读性、一致性和软件质量。代码的长度往往只有C++或Java代码的1/5~1/3。采取了一种所谓极简主义的设计理念。
Python是一门通用型的编程语言，但时常扮演脚本语言的角色。“脚本（script）”往往倾向于描述简单的顶层代码文件，而“程序（program）”则用来描述那些相对复杂一些的多文件应用。
Python重大且普遍的唯一缺点是，与C这类完全编译并且较底层的语言相比，Python的执行速度还不够快。目前，Python的标准实现方式是将源代码的语句编译为字节码（byte code），然后将字节码解释出来。
Python通过C/C++系统进行扩展以及嵌入C/C++系统的特性，使其能够作为一种灵活的粘合语言，可以脚本化处理其他系统的组件的行为。  
Python的类模型支持多态、运算符重载和多重继承等高级概念。  
Python的C语言API可以帮助Python程序灵活调用C语言。

# Python如何运行程序

> 本章学习Python解释器如何执行程序。

**解释器**是一种让其他程序运行起来的程序，是代码与计算机硬件之间的软件逻辑层。
一个**python程序**是一个包含python语句的文本文件。当Python运行脚本时，在代码开始处理之前，Python会首先将脚本编译成所谓的“字节码”，然后将其转发到所谓的“虚拟机”中。**字节码**是一种低级的、与平台无关的表现形式。Python将字节码保存为一个以.pyc为扩展名的文件，放在名为__pycache__的子目录中[^1]。

[^1]:Python这样保存字节码是为了优化启动速度，下一次运行程序时，如果上次保存的程序没有修改，那么Python就会跳过编译这个步骤，直接加载.pyc文件。字节码只针对那些被导入(import)的文件而生成，而不是顶层的执行脚本。

**Python虚拟机**(PVM)是迭代运行字节码指令的一个大循环，一个接一个地完成操作。
Python在程序开始执行之前不需要预编译和链接，只需要简单地输入并运行代码即可。这让其具有浓厚的动态语言色彩：在运行时，Python程序构建并执行另一个Python程序。这种结构让Python能够实现产品定制。因为Python代码可以动态地被修改，用户可以改进系统内部的Python部分，而不需要拥有或编译整个系统的代码。
Python语言有5中主要的实现方式——CPython、Jython、IronPython、Stackless和PyPy[^2]。

[^2]:其中CPython是标准的实现，由可移植的ANSI C语言代码编写而成，Jython的目标是让Python代码能够脚本化Java应用程序，IronPython为了满足在.NET组件中集成Python的开发者，Stackless是标准CPython针对并发性而优化的一个增强实现，PyPy提供了一个即时编译器(Just-In-Time, JIT)，将字节码中的部分直接转换成运行速度更快的二进制机器码，从而运行速度更快。

# 你应如何运行程序

> 本章的目标是学习如何运行Python代码

在命令行输入Python，依赖于系统帮我们在程序搜索路径中定位Python程序的位置。如果没有设置系统的PATH环境变量来包括Python的安装路径，就要输入完整路径来代替单词“python”[^3]。

[^3]:这里讲清楚了系统环境变量PATH的含义：即系统用来搜索应用程序的目录。

为了永久保存程序，需要在文件中写入代码，这样的文件通常叫作模块。**模块**是一个包含了Python语句的简单文本文件。它是Python程序最大的程序结构，也是这门语言的首要概念之一。

Windows的**注册表**是个多层的数据库，用来储存系统和应用程序的配置信息。数据库可以保证多进程、多线程读写不出错。

任何一个以扩展名.py截尾的Python源代码文件都是一个模块，其他文件可以通过导入一个模块来读取这个模块定义的内容。**导入操作**本质上就是载入另一个文件，并给予读取那个文件内容的权限。一个模块的内容通过其属性从而被外界使用[^4]。

[^4]:导入是一个开销很大的操作，以至于每个文件、每个程序不能重复运行多于一次。 如果需要再次导入一个模块，需要调用reload函数。

导入和重载提供了一种自然的程序启动选项，因为导入操作将会在最后一步执行文件[^5]。模块扮演了一个工具库的角色，它往往就是变量名的包（即命名空间），而在那个包中的变量名称就是属性。**属性**就是绑定在特定对象上的变量名。

[^5]:导入就是Python在sys.path里列出的每一个目录中搜索导入的模块：sys.path是sys模块里目录名称字符串的Python列表，它从PYTHONPATH环境变量中获得初始化，加上一个标准目录集。

from语句从模块中复制出变量名，即改变了命名空间。
dir函数，可以获得模块内部的全部变量名列表。

# 介绍Python对象类型

在Python中，我们使用“材料”来处理“事务”。“事务”指的是像加法以及拼接这样的操作形式，而“材料”指的是我们操作的对象。

在Python中，数据以对象的形式出现，Python脚本中的一切都是对象。

Python程序可以分解成模块、语句、表达式以及对象：

1. 程序由模块构成。
2. 模块包含语句。
3. 语句包含表达式。
4. 表达式创建并处理对象。

编程的三大支柱：顺序语句（执行这一条，然后下一条）、选择语句（当那个值为真时，执行这一条）和循环语句（重复执行多次这一条）。

Python**内置对象类型**：
数字、字符串、列表、字典、元组、文件、集合、其他核心类型、程序单元类型、Python实现相关类型

**字面量**可以理解为那些产生对象的表达式，有时也称为常量。

Python中没有类型声明，运行的表达式语法决定了创建和使用的对象的类型。

## 字符串

字符串是由单字符的字符串所组成的序列，其他更一般的序列类型还包括列表和元组。

当给一个变量赋值时就创建了它，当变量出现在一个表达式中时，就会用其值替换它。

可以在Python的方括号中使用任意表达式，而不仅仅是数字字面量。只要Python需要一个值，就可以使用一个字面量、一个变量或任意表达式。

**多态**，即一个操作的意义取决于被操作的对象。

字符串具有**不可变性**，即在创建后不能原位置（in place）改变。例如，不能通过对其某一位置进行赋值而改变字符串，但可以通过建立一个新的字符串并以同一个变量名对其进行赋值。在核心类型中，数字、字符串和元组是不可变的；列表、字典和集合是可变的。

**方法**指的是依赖并作用于对象上的函数，并通过一个调用表达式触发。

Python的工具库是呈层级分布的：可作用于多种类型的通用操作都是以内置函数或表达式的形式出现的（如len(X),X[0]），但是类型特定的操作是以方法调用的形式出现的（如aString.upper()）。

以双下划线开头并结尾的变量名用来表示Python实现细节的命名模式，而这个列表中没有下划线的属性是字符串对象能够调用的方法。

**编码**（coding）是指用代码来表示各组数据资料，使其成为可利用计算机进行处理和分析的信息。代码是用来表示事物的记号，它可以用数字、字母、特殊的符号或它们的组合来表示。

日常接触到的文件分ASCII和Binary两种。前者规定了用0到127的128个数字代表信息的规范编码，包括33个控制码、1个空格，94个形象码（英文字母、数字、标点）。

除了ASCII用掉的128个数字，一个字符占8个2进制位256个数字。其余数字和33个控制符编码方式为Binary。

Unicode即统一码。Unicode是宽字节字符集，它对每个字符都固定使用两个字节，即16为表示。

“文本文件”指ASCII。“二进制文件”指Binary。“通用字符”“万国码”指Unicode“统一码”。

字符串前加“u/U”表示Unicode字符串，一般英文字符在使用各种编码下都可正常解析，所以一般不带u；中文要表明所需编码，否则易出乱码。“r/R”表示非转义的原始字符串。“b：bytes”Python 3.0 的默认str是unicode，bytes与str可互相转化。

.encode()编成b'\...'
.decode()转成码u'\...'

Unicode的操作大部分都能归为与文件之间进行文本的来回传输：文本在存入文件时会被编码成字节，而在读入内存时会被解码成字符（也称“码”）。
字节：bytes
字符：码
编码后是bytes字节，解码后是str字符。

## 列表

**列表**是一个任意类型的对象的位置相关的有序集合，它没有固定的大小。

**列表推导**源自数学中集合的概念。它是一种通过对序列中的每一项运行一个表达式来创建一个新列表的方法，每次一个，从左到右。列表推导是编写在方括号中的，并且由使用了同一个变量名的表达式和循环结构组成。
> doubles = [c*2 for c in 'spam']

列表、集合、字典和生成器都可以用推导来创建。

## 字典

**字典**不是序列，而是一种映射（mapping）。通过键（key）而不是相对位置来存储对象。

通过键来索引一个字典往往是Python中编写搜索的最快方法。

**if/else三元表达式**（实质上是挤在一行中的一条if语句）
> value = D['x'] if 'x' in D else 0

一个**可迭代对象**可以是内存中物理存储的序列，也可以是一个在迭代操作情况下每次产生一个元素的对象——一种“虚拟”的序列。**迭代协议**在响应next之前先用一个对象对iter内置函数做出响应，并在结束时触发一个异常。

## 元组

**元组**（tuple）基本上就是一个不可以改变的列表。功能上，它用来表示确定元素的集合。

## 文件

**文件**是Python代码调用电脑上存放的外部文件的主要接口。

对脚本而言，无论文件包含的数据是什么类型，文件的内容总是字符串。

文本文件把内容显示为正常的str字符串，而二进制文件把内容显示为一个特定的字节字符串。

## 其他核心类型

**集合**是不可变的对象的无序集合。一个集合的行为很想一个有键无值的字典。

因为Python中{}表示字典，所以空集合通过内置函数set来创建。
> s = set()

集合是处理过滤重复对象、分离集合间差异、进行非顺序的等价判断等任务的利器。

集合只能包含不可变的（可哈希化的）对象类型。列表和字典不能嵌入到集合中。集合本身也是可变的，因此不能直接嵌入到其他集合中。如果需要在另一个集合中存储一个集合，可以像调用set一样调用内置函数frozenset，但fronzenset会创建一个不可变的集合。

**十进制数**
> import decimal
> d = decimal.Decimal('3.141')

**分数**
> from fractions import Fraction
> f = Fraction(2,3)

**布尔值**(预定义的True和False对象实际上定制化的1和0)

**None**是特殊的占位符，通常用来初始化变量和对象。None是一个真正的对象，有一块真实的内存，None是Python给定的一个内置名称。

## 用户定义的类

**类**定义了新的对象类型，扩展了核心类型。

隐含的"self"对象是我们把这叫作面向对象模型的原因：一个类中的函数总是有一个隐含的对象。

# 数值类型

在Python中，数据采用了对象的形式。

在Python中，数字并不真的只是一种对象类型，而是一组相似类型的分类。Python不仅支持通常的数值类型（整数和浮点数），还提供了字面量来直接创建数字和表达式以处理数字。

**字面量**（literal）用于表达源代码中一个固定值的表示法（notation），整数、浮点数以及字符串等都是。总之，字面量就是没有用标识符封装起来的量，是“值”的原始状态。**标识符**是编程时使用的名字。

完整的Python数值类型工具包括：整数和浮点对象、复数对象、小数：固定精度对象、分数：有理数对象、集合：带有数值运算的集合体、布尔值：真和假、内置函数和模块：round|math|random等、表达式；无限制整数精度；位运算；十六进制|八进制|二进制格式、第三方扩展：向量|库|可视化|作图等。

十六进制数以0x或0X开头，后面接十六进制的数字0-9和A-F。八进制数字面量以数字0o或0O开头，后面接着数字0-7构成的数字串。二进制字面量以0b或0B开头，后面跟二进制数字0-1。内置函数hex(I)、oct(I)、bin(I)把一个整数转换为这3种进制表示的字符串。

**复数**字面量为实部+虚部，虚部以j或J结尾。从内部看，复数是通过一对浮点数实现的。复数也可以通过内置函数complex(real, imag)来创建。

**表达式**是处理数字最基本的工具，表达式的定义是：数字（或其他对象）与运算符相组合，并被Python在执行时计算为一个值。

**变量**就是名称，可以用于记录程序中的信息。

str和repr显示格式
从技术上来说，默认的交互式命令行显示和print的区别，相当于内置repr和str函数的区别。str和repr都会把任意对象转换成对应的字符串表示：repr会产生看起来像代码的结果。str转换为一种通常对拥护更加友好的格式。对象同时拥有这两种方式：str用于一般用途，repr带有额外细节。

浮点数因为有限的比特位数，而不能精确地表示某些值的事实，是数值编程的一个基本问题。

X/Y是经典除法和真除法。
X//Y是向下取整除法。

**模块**是外部的组件，而内置函数则位于一个隐含的命名空间内，而Python会自动在这个命名空间中搜索程序中的名称。
> Python的标准库模块是builtins

**布尔型**，名称True和False是bool的实例，而bool实际上只是内置整数类型int的自雷。True和False的行为与整数1
和0是一样的，只不过有独特的显示逻辑。

## 数值扩展

数值编程是Python的一个热门领域。一个叫作NumPy的可选Python扩展提供了高级的数值编程工具。

# 动态类型

动态类型以及由它提供的多态性，这些概念是Python语言简洁性和灵活性的基础。

在Python中，类型是在运行时自动决定的，而不是通过代码声明。

**变量创建**，一个变量（也就是变量名），当代码第一次给它赋值时创建了它，之后的赋值将会改变已创建的变量名的值。
**变量类型**，变量永远不会拥有任何和它关联的类型信息或约束。类型的概念存在于对象，而不是变量名中。
**变量使用**，当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。

在Python中，从变量到对象的链接称作引用。引用是一种关系，通过内存中的指针的形式来实现（在内部，变量事实上是到对象内存空间的一个指针）。

每一个对象都有两个标准的头部信息：类型标志符（type designator）标识这个对象的类型；引用的计数器（reference counter）决定何时收回这个对象。

在Python中，每当一个变量名被赋予一个新的对象，如果原来的对象没有被其他的变量名或对象所引用的话，那么之前的那个对象占用的空间就会被回收。这种自动回收对象空间的技术叫作垃圾回收。在内部，Python在每个对象中保留了一个计数器，计数器记录当前指向该对象的引用的数目。一旦这个计数器被设置为零，这个对象的额内存空间就会自动回收。

对于支持原位置修改的对象类型，共享引用时要加倍小心，因为对一个变量名的修改会影响其他的变量。考虑到所有的赋值都是基于引用，这种风险普遍存在。要避免这个问题，可以复制（copy）对象，而不是创建引用。

# 字符串基础

对于一些程序员，尤其是互联网领域工作的那些而言，Unicode是一个关键工具。

Python分别使用字符串对象类型和文件接口，用来区分文本和二进制数据。Python有三种字符串类型：str用于Unicode文本（包括ASCII），bytes用于二进制数据（包括已编码的文本），而bytearray是bytes的一个可修改的变体。

字符串是我们将要学习的名为序列的一大类对象的第一个代表。

## 常见的字符串字面量和操作

s = ''      空字符串
s = "spam's"    双引号，和单引号相同
s = 's\np\ta\x00m'    转义序列
s = """...multiline..."""   三引号块字符串
s = r'\temp\spam'   原始字符串（不进行转义）
B = b'sp\xc4m'  3.X中的字符串
U = u'sp\u00c4m'    Unicode字符串
s1+s2   拼接
s*3 重复
s[i]    索引
s[i:j]  分片
len(s)  长度
"a %s parrot" % kind    字符串格式化表达式
"a {0} parrot".format(kind)     3.X中的字符串格式化方法
s.find('pa')    字符串方法：搜索
s.rstrip()  移除右侧空白
s.replace('pa', 'xx')   替换
s.split(',')    用分隔符分组
s.isdigit()     内容测试
s.lower()   大小写转换
s.endwith('spam')   尾部测试
'spam'.join(strlist)    分隔符连接
s.encode('latin-1') Unicode编码
B.decode('utf8')    Unicode解码等
for x in s: print(x)    迭代
'spam' in s     成员关系
[c*2 for c in s]    成员关系
map(ord, s)     ord返回单个字符的ASCII序号
re.match('sp(.*)am', line)  模式匹配：库模块

在Python字符串周围，单引号和双引号字符是可以互换的。支持这两种形式的原因是，你不进行反斜杠转义就可以在一种引号的字符串中包含另一种引号。

反斜杠用来引入特殊的字符编码，称为转义序列。

## 字符串反斜杠字符

\newline    被省略（行的延续）
\\  反斜杠（保留一个\）
\`  单引号（保留`）
\"  双引号（保留"）
\a  响铃
\b  退格
\f  换页
\n  换行
\r  回车
\t  水平制表符
\v  垂直制表符
\xhh    十六进制值hh的字符（准确为2个数位）
\ooo    八进制值ooo的字符（可达3个数位）
\0      空字符：二进制的0字符
\N{id}  Unicode数据库ID
\uhhhh  16位十六进制值的Unicode字符
\Uhhhhhhhh      32位十六进制值的Unicode字符
\other  不转义（保留\和other）

**方法调用语法**

函数就是代码包，而方法调用同时结合了属性获取和函数调用。

**属性获取**，具有object.attribute形式的表达式可以理解为“获取对象object中attribtue属性的值”。

**调用表达式**，具有function(arguments)形式的表达式可以理解为：“调用函数function的代码，向其传递零个或多个逗号分隔的参数argument对象，并且返回函数function的结果值。”

两个合用，可以调用一个对象方法：object.method(arguments)

## 字符串格式化表达式

字符串格式化表达式：'...%s...' % (values)

- 在%运算符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或多个内嵌的转换目标，都以%开头(如%d)
- 在%运算符右侧放置一个或多个，内嵌在元组中的对象，这些对象将会插入到你想让python进行格式化的左侧的字符串中，并替换一个或多个转换目标
  - 用法: 'This is %d %s bird!' % (1, 'dead')
- 字符串格式化的类型码
  - s 字符串
  - r 与s相同，但使用repr，而不是str
  - c 字符（int或str）
  - d 十进制数字
  - o 八进制整数
  - x 十六进制整数
  - X 与x相同，但是使用大写字母
  - e 带有指数的浮点数，小写
  - E 与e相同，但是使用大小写字母
  - f 十进制浮点数
  - F 与f相同，但是使用大写字母
  - g 浮点数e或f
  - G 浮点数E或F
  - % %字面量（编码为%%）
- 转换目标的一般结构：%[(keyname)][flags][width][.precision]typecode
  - 在%和类型码字符之间，可以为索引在表达式右侧使用的字典提供键名称，罗列出说明格式的标签，如左对齐（-）、数值符号（+）、正数前的空白以及负数前的-（空格）和零填充（0），被替换的文本给出总的最小字段宽度，为浮点数设置小数点后显示的位数
  - 用法：x = 1234, res = 'integers: ...%d...%-6d...%06d' % (x,x,x)
- 基于字典的格式化表达：字符串格式化同时也允许左边的转换目标引用右边编写的字典中的键来提取对应的值。
  - 用法：'%(qty)d more %(food)s' % {'qty':1, 'food': 'spam'}

字符串格式化方法调用: '...{}...'.format(values)

- 用法:
  - '{motto}, {0} and {food}'.format(42, motto = 3.14, food = [1, 2])
  - 'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})
  - 'My {map[kind]} runs {sys.platform}'.format(sys=sys, map={'kind': 'laptop'})
- 格式化字符串中添加额外的语法：{fieldname component !conversionflag: formatspec}
  - fieldname是辨识参数的一个可选的数字或关键字
  - component是有着大于等于零个".name"或“[index]”引用的字符串，它可以被省略以使用完整的参数值。
  - conversionflag如果出现则以!开始，后面跟着r、s或者a，在这个值上分别调用repr、str或ascii内置函数
  - formatspec如果以:开始，后面跟着文本，制定了如何表示该值，包括字段宽度、对齐方式、补零、小数精度等细节，并且以一个可选地额数据类型码结束。
  - 冒号后面的formatspec组件本身也有着丰富的格式，形式上的描述如：[[fill][align][sign][#][0][width][,][.precision][typecode]]
- 用法：
  - '{0:10} = {1:10}'.format('spam', 123.4567)
  - '{0:>10} = {1:<10}'.format('spam', 123.4567)
  - '{0.platform:>10} = {1[kind]:<10}'.format(sys, dict(kind='laptop'))
  - '{0:f}, {1:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159)

format方法拥有%表达式所没有的很多高级功能。
> data = dict(platform=sys.platform, kind='laptop')
> 'My {kind:<8} runs {platform:>8}'.format(**data)
> 这里方法调用中的**data是特殊的语法，它把一个由键值对组成的字典解包为一组组像“name=value”的关键字参数。

Python中的三大操作类型：

1. 数字（整数、浮点数、小数、分数等）。支持加法和乘法等。
2. 序列（字符串、列表、元组）。支持索引、分片和拼接等。
3. 映射（字典）。支持按键名称的索引等。

Python中的主要核心类型划分为两类：

1. 不可变类型（数字、字符串、元组、不可变集合）。不可变类别中的对象类型都不支持原位置修改。
2. 可变类型（列表、字典、集合、字节数组）。可变类型总是可以在原位置修改，而不用创建新的对象。

# 列表与字典

列表是Python中最具灵活性的有序集合对象类型。

列表是：任意对象的有序集合；通过偏移访问；可变长度、异构以及任意嵌套；属于“可变序列”的分类；对象引用数组（在标准python解释器内部，列表就是c数组而不是链接结构）。

## 常用列表字面量和操作

- for x in L: print(x)  迭代
- 3 in L    成员关系
- L.append(4)   尾部添加
- L.extend([5,6,7]) 尾部扩展
- L.insert(i, x)    插入
- L.index(x)    索引
- L.count(x)    统计元素出现次数
- L.sort()  排序
- L.reverse()   反转
- L.copy()  复制
- L.clear() 清除
- L.pop(i)  删除i处元素
- L.remove(x)   删除元素x
- del L[i]  删除i处元素
- del L[i:j]    删除i到j处的片段
- L[i:j] = []   删除i到j处的片段
- L[i] = 3
- L[i:j] = [4 ,5, 6]    分片赋值
- L = [x**2 for x in range(5)]  列表推导和映射
- list(map(ord, 'spam'))

**列表推导**只不过是通过对序列（事实上，可以推广到鄋的可迭代对象）中的每一项应用一个表达式来构建一个新的列表的方式。

- res = [c*4 for c in 'SPAM']
内置函数map能实现类似的效果，但对序列中的各项应用一个函数并把结果收集到一个新的列表中：
- list(map(abs, [-1, -2, 0, 1, 2]))

L.append(x)与L+[x]的结果类似，不同的是，前者会原位置修改L，而后者会生成新的列表。

- 表达式会创建新的对象。

字典的索引是一种非常快速的搜索操作。字典是作为散列表来实现的。

Python字典的主要属性：通过键而不是偏移量来读取；任意对象的无序集合；长度可变、异构、任意嵌套；属于“可变映射”类型；对象引用表（散列表）。

## 常见字典字面量和操作

- D = {}    空字典
- D = {'name': 'Bob', 'age': 40}    有两个元素的字典
- E = {'cto': {'name': 'Bob', 'age': 40}}   嵌套
- D = dict(name = 'Bob', age = 40)  其他构造方法：关键字
- D = dict([('name', 'Bob'), ('age', 40)])  键值对
- D = dict(zip(keyslist, valslist)) 拉链式键值对
- D= dict.fromkeys(['a', 'b'])  键列表
- D['name'] 通过键索引
- E['cto']['age']   嵌套索引
- 'age' in D    成员关系：键存在测试
- D.keys()  方法：所有键
- D.values()    所有值
- D.times() 所有“键+值”元组
- D.copy()  复制（顶层的）
- D.clear() 清除（删除所有项目）
- D.update(D2)  通过键合并
- D.get(key, default?)  通过键获取，如果不存在默认返回None
- D.pop(key, default?)  通过键删除，如果不存在返回错误
- D.setdefault(key, default?)   通过键获取，如果不存在默认设置为None
- D.popitem()   删除/返回所有的（键，值）对
- len(D)    长度（储存的键值对的对数）
- D[key] = 42   新增/修改键，删除键
- del D [key]   根据键删除条目
- list(D.keys())
- D1.keys() & D2.keys()
- D = {x: x*2 for x in range(10)}   字典推导

在Python标准库中，有可以维护键插入顺序的扩展类型，参见collections模块中的OrderedDict，不过它们通过使用额外空间并降低速度来实现其功能。

在字典中一个键只有一个值，但一个值可以有多个键与之对应，并且一个值本身可以是一个集合。

# 元组、文件与其他核心类型

**元组**是任意对象的有序集合；通过偏移量存取；属于“不可变序列”；固定长度、多样性、任意嵌套；对象引用的数组。

## 常见元组字面量和运算

- ()  空元组  
- T= (0, )  单个元素的元组
- T = (0, 'Ni', 1.2, 3)   四个元素的元组
- T= 0, 'Ni', 1.2, 3  另一种四个元素的元组
- T = ('Bob', ('dev', 'mgr'))   嵌套元组
- T = tuple('spam')   一个可迭代对象的元素组成的元组
- T[i]  索引
- T[i][j] 索引的索引
- T[i:j]  分片
- len(T)  长度
- T1+T2 拼接
- T*3 重复
- for x in T: print(x)  迭代
- 'spam' in T 成员关系测试
- [x**2 for x in T]
- T.index('Ni') 搜寻方法
- T.count('Ni') 计数方法
- namedtuple('Emp', ['name', 'jobs']) 有名元组扩展类型

要注意，元组的不可变性只适用于元组本身**顶层**而非其内容。

列表推导实际上可以被视作一种迭代工具。

文件是计算机中由操作系统管理的具有名称的存储区域。

内置函数open能够创建一个对象，作为到计算机上某个文件的链接。

## 常见的文件操作

- output = open(r'C:\spam', 'w')  创建输出文件('w'代表写入)
- input = open('data', 'r') 创建输入文件('r'代表读入)
- input = open('data')  与上一行相同('r'是默认值)
- aString = input.read()  把整个文件读进一个字符串
- aString = input.read(N) 读取接下来的N个字符到一个字符串
- aString = input.readline()  读取下一行(包含\n换行符)到一个字符串
- aList = input.readlines() 读取整个文件到一个字符串列表(包含\n换行符)
- output.write(aString) 把字符串(或字节串)写入文件
- output.writelines(aList)  把列表内所有字符串写入文件
- output.close()  手动关闭
- output.flush()  把输出缓冲区刷入硬盘中，但不关闭文件
- anyFile.seek(N) 把文件位置移动到偏移量N处以便进行下一个操作
- for line in open('data'): use line  文件迭代器逐行读取
- open('f.txt', encoding='latin-1') Unicode文本文件(str字符串)
- open('f.bin', 'rb') 字节码文件

程序调用内置函数open打开一个文件，open函数返回一个文件对象，这个对象带有可以传输数据的方法：
>>> afile = open(filename, mode)
>>> afile.method()
>>> open('test', mode='w+', encoding='utf-8')

- open函数的第1个参数是外部文件名，它可能含有一个与平台相关的绝对或相对路径前缀。如果没有这个目录路径，文件被默认为存在当前工作目录下。
- open函数的第2个参数是处理模式，字符串'r'表示以输入模式打开，'w'表示以输出模式生成并打开文件，'a'表示在文件尾部追加内容并打开文件。
- open函数的第3个参数可选，能够控制输出缓冲：'0'意味着输出无缓冲。
- 在模式字符串中加上b可以进行二进制数据的处理。加上"+"意味着被打开文件同时支持输入输出。

在任何情况下，文件的文本在Python程序中都采用字符串的形式。读取文件时会返回字符串形式的文本，写入文件时的文本作为字符串被传入write方法。

文件读写方法提示：文件迭代器最适合逐行读取；内容是字符串，不是对象；文件是被缓冲的以及可定位的；close通常是可选地：回收时自动关闭。

如果想逐行扫描一个文本文件，文件迭代器往往是最佳选择：
>>> for line in open('myfile.txt'):
>>> print(line, end='')

- 这种形式通常最容易编写，有更高的内存使用效率，并且比其他方式都更快。

**文本文件**把内容表示为常规的str字符串，自动执行Unicode编码和解码，并且默认执行末行转换。
**二进制文件**把内容表示为一个特殊的bytes字节串类型，并且允许程序不修改地访问文件内容。
在Python3.X中，所有的字符串事实上都是Unicode。

存储Python原生对象：pickle
> pickle模块是能够让我们直接在文件中存储几乎任何Python对象的高级工具，同时不需要我们对字符串进行来回转换。
存储字典：
>>> D = {'a':1, 'b':2}
>>> F= open('datafile.pkl', 'wb')
>>> import pickle
>>> pickle.dump(D, F)
>>> F.close()
取回字典对象：
>>> F = open('datafile.pkl', 'rb')
>>> E = pickle.load(F)
>>> E
{'a':1, 'b':2}

用JSON格式存储Python对象：
> JSON是一种新兴的数据交换格式，既是语言无关的，也支持多种系统。
>>> rec = dict(first='Bob', last='Smith')
>>> import json
>>> s = json.dumps(rec)
>>> o = json.loads(s)
>>> o
{'first':'Bob','last':'Smith'}

存储打包二进制数据：struct
> struct模块能够构造并解析打包二进制数据，即能够把文件中的字符串转换为二进制数据。
>>> F = open('data.bin', 'wb')
>>> import struct
>>> data = struct.pack('>i4sh', 7, b'spam', 8)
>>> data
b'\x00\x00\x07spam\x00\x08'
>>> F.write(data)
>>> F.close()

>>> = open('data.bin', 'rb')
>>> data = F.read()
>>> data
b'\x00\x00\x07spam\x00\x08'
>>> values = struct.unpack('>i4sh', data)
>>> values
(7, b'spam', 8)

文件上下文管理器：
>>> with open(r'C:\code\data.txt') as myfile:
>>> for line in myfile:
>>> ... use line here ...

- with上下文管理器方案能保证操作系统资源的释放，并且对于确保刷新输出文件缓冲区更加有用。

赋值操作**总是**存储对象的引用，而不是这些对象的副本。如果你不想这么做，就要显式地告诉Python复制该对象。

进行复制的操作：

- 没有参数的分片表达式(L[:])可以复制序列。
- 字典、集合或列表的copy方法。
- 诸如list、dict、set的内置函数可以进行复制。
- copy标准库模块能够在需要时创建完整副本。
- 注意：无参数的分片以及字典的copy方法只能进行顶层复制，不能复制嵌套的数据结构。如果需要创建深层嵌套数据结构，可以使用标准库copy模块: copy.deepcopy()。

**引用**是其他语言中指针的更高级模拟。
如果一个复合对象包含指向自身的引用，就称之为循环对象：
>>> L = ['grail']
>>> L.append(L)
>>> L
['grail', [...]]

Python系统中的一切都是对象类型，而且可以由Python程序来处理。

# Python语句简介

Python程序的结构：

1. 程序由模块构成
2. 模块包含语句
3. 语句包含表达式
4. 表达式创建并处理对象

## Python语句

- 赋值  创建引用值  a, b = 'good', 'bad'
- 调用与其他表达式  运行函数  log.write("spam, ham")
- print调用 打印对象  print('The Killer', joke)
- if/elif/else  选择动作  if"python" in text: print(text)
- for/else  序列迭代  for x in mylist: print(x)
- while/else  通用循环  while X > Y:\\ print('hello')
- pass  空占位符  while True:\\ pass
- break 循环退出  while True:\\ if exittest(): break
- continue  循环继续  while True:\\ if skiptest(): continue
- def 函数与方法  def f(a, b, c=1, *d):\\ print(a+b+c+d[0])
- return  函数结果  def f(a, b, c=1, *d):\\ return a+b+c+d[0]
- yield 生成器函数  def gen(n):\\ for i in n: yield i*2
- global 命名空间  x = 'old'\\  def function():\\ global x, y; x = 'new'
- nonlocal  命名空间  def outer():  x = 'old'\\ def function():\\ nonlocal x; x = 'new'
- import  获取模块  import sys
- from  获取属性  from sys import stdin
- class 构建对象  class Subclass(Superclass):\\ staticData = []\\def method(self): pass
- try/except/finally  捕捉异常  try:\\ action()\\ except:\\ print('action error')
- raise 触发异常  raise EndSearch(location)
- assert  调试检查  assert X> Y, 'x too small'
- with/as 上下文管理器  with open('data') as myfile:\\ process(myfile)
- del 删除引用  del data[k]\\ del obj.attr\\del variable

Python所有复合语句都有冒号(：)，置于首行的结尾处。
Python一行的结束会自动终止该行的语句，所以可以省略结尾的(；)号。
如果要让一条语句跨越多行，可以用括号把语句括起来，或者在上一行结尾加反斜杠(\)。
缩进的结束就是代码块的结束。

# 赋值、表达式和打印

赋值语句创建对象引用，而不是复制对象；变量在首次赋值时会被创建；变量在引用前必须先赋值；某些操作会隐式地进行复制（模块导入、函数和类定义、for循环变量、函数参数）。

赋值语句形式：

- spam = 'Spam'   基础形式
- spam, ham = 'yum', 'YUM'    元组赋值（基于位置）
- [spam, ham] = ['yum', 'YUM']    列表赋值（基于位置）
- a, b, c, d = 'spam'   推广的序列赋值
- a, *b = 'spam'    扩展序列解包
- spam = ham = 'lunch'    多目标赋值
- spams += 42   增量赋值

带有单个星号的名称*x，可以用在赋值目标中，来制定对于序列的一个通用匹配方式：带星号的名称会被赋值一个列表，该列表收集了序列中剩下的没被赋值给其他名称的所有项。要是带星号的名称只匹配到单个的项，也向其赋值一个列表，如果剩下的内容为空，则赋值一个空列表。

## 增量赋值语句

- x += y
- x &= y
- x -= y
- x |= y
- x *= y
- x ^= y
- x /= y
- x >>= y
- x %= y
- x <<= y
- x **= y
- x //= y

增量赋值适用于任何支持了相应二元表达式的对象类型。

增量赋值语句的优点：

- 减少程序员的输入。
- 左侧只需计算一次。而在完整形式 x = x+y中，x会出现2次，所以也必须执行两次。
- 增量赋值有着自动选择的优化技术。

拼接操作必然会创建一个新对象，把加号左侧和右侧的列表都复制到其中。相反，原位置方法调用直接在一个内存块末尾添加项。

变量命名规则：

- 语法：（下划线或字母）+（任意数目的字母、数字或下划线）
- 区分大小写：SPAM和spam并不同
- 禁止使用保留字
- 以单一下划线开头的名称(_x)不会被from module import *语句导入
- 前后均有双下划线的名称(**x**)是系统定义的名称，对解释器有特殊意义
- 以双划线开头，但结尾没有双下划线的名称(__x)是外围类的本地变量
- 通过交互式命令行运行时，只有单个下划线的名称(_)会保存最后一个表达式的结果。

## 常见的Python表达式语句

- spam(eggs, ham)   函数调用
- spam.ham(eggs)    方法调用
- spam    在交互式解释器中打印变量
- print(a,b,c,sep='')   打印
- yield x**2    yield表达式语句

表达式语句常常用于执行可以在原位置修改列表的列表方法：
>>> L = [1, 2]
>>> L.append(3)
>>> L
[1, 2, 3]
然而，Python初学者时常把这种操作写成赋值语句：
>>> L = L.append(4)
>>> print(L)
None

## 打印操作

- 标准输出流，也常称stdout，是发送一个程序文本输出的默认位置。
- print函数形式：print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
  - sep是在每个对象的文本之间插入的一个字符串，默认是一个空格。
  - end是添加在打印文本末尾的一个字符串，默认是一个\n换行符。
  - file指定了文本将要发送到文件、标准流或其他类似文件的对象，默认是sys.stdout。
  - flush立即刷新输出，默认是false。

打印流重定向

- print(x)等价于sys.stdout.write(str(x)+'\n')
- 可以sys.stdout赋值给标准输出流以外的对象，例如：

>>> import sys
>>> sys.stdout = open('log.txt', 'a')
>>> print(x)

- 通过将sys.stdout重设指向文件log.txt，之后print语句**都会**将文本写至文件log.txt的末尾。
- file关键字也可以将打印重定向: print(x, file='log.txt')

# if测试和语法规则

复杂if语句：
>>> if choice = 'ham':
            print(1.25)
        elif choice = 'eggs'"
            print(0.99)
        else:
            print(2.02)
上面语句等价于：
>>> print({'ham': 1.25,
                   'eggs': 0.99,
                   'bacon': 2.02}[choice]
)
还等价于：
>>> branch = {'ham': 1.25,
                         'eggs': 0.99,
                         'bacon': 2.02}
>>> print(branch.get('ham', 'Bad choice'))

- 运行if选择分支比较慢，如果用字典判断更快。

## Python语法规则

- 语句是逐个运行的，除非遇到if等控制流语句。
- 快和语句的边界会自动被解释器识别。
- 符合语句 = 首行 + ":" + 多个缩进语句。
- 空白行、空格以及注释通常都会被忽略。
- 文档字符串(docstring)会被忽略，但会被保存并由工具显示。

## 三种布尔表达式运算符

- X and Y
- X or Y
- not X

> 布尔运算符在Python中是单词（不是C语言中的&&、||和!）。
> 布尔and和or运算符在Python中会返回真或假对象，而不是True或False
> or表达式，Python会由左到右计算操作对象，并返回第一个为真的操作对象，并且在其找到第一个真值操作数的地方停止:
>>> 2 or 3, 3 or 2
(2, 3)
>>> [] or 3
3
>>> [] or {}
{}
> 因为or运算符会返回其左右的两个对象之一，这称为Python中相当常见的代码编写技巧：从一个固定大小的集合中选择非空的对象：
>>> X = A or B or C or None
> 这会把X设为A、B、C中第一个非空的对象；如果都为空则设为None。

if/else三元表达式:
>>> A = Y if X else Z

因为所有对象本质都是真或假，所以在Python中，直接测试对象(if X:)比空值比较(if X != '':)更为常见和简单。

# while循环和for循环

while语句提供了一种编写通用循环的方式；for语句可以遍历序列或其他可迭代对象内的元素，并对每一个元素运行一段代码块。

while语句最完整的形式是：首行以及测试表达式有一行或多行正常缩进语句构成的主体以及一个可选的else部分：
>>> while test:
      statements
    else:
      if test: break
      if test: continue
      statements

break：跳出最近所在的外围循环。

continue：跳到最近所在外围循环的头部。

pass：什么事也不做，只是一条空占位语句。

循环else块：当且仅当循环正常离开时才会执行（也就是没有碰到break语句）。

for循环是一个通用的序列迭代器：它可以遍历任何有序序列或其他可迭代对象内的元素。for循环首行制定一个赋值目标，以及你想遍历的对象，后面跟你想重复的语句块：
>>> for target in object:
      statements
      if test: break
      if test: continue
    else:
      statements

对于逐行读取文本文件，for循环是最易于编写且执行最快的：
>>> for line in open('test.txt').readlines():
      print(line.rstrip())

- readlines方法一次性把文件载入成每行字符串的列表。

>>> for line in open('test.txt'):
      print(line.rstrip())

- 该例借助文件迭代器自动在每次循环迭代的时候读入一行。

通常for循环比while循环更容易写，执行的更快。因为for由迭代器实现，而迭代器在Python内部以C语言的速度运行。while循环版本则通过虚拟机运行Python字节码。

Python提供了一套内置函数，可以帮你在for循环中定制迭代：

- range返回一系列连续增加的整数，可作为for中的索引。
- zip返回一系列并行元素的元组，可用于在for中遍历多个序列。
- enumerate同时生成可迭代对象中元素的值和索引，因而我们不必再手动计数。

## 修改列表

对于列表L = [1,2,3]，用for x in L: x += 1这种方式并不奏效，因为你修改的是循环变量x，而不是列表L。要在遍历列表时对其进行修改，必须借助索引：
>>> for i in range(len(L)):
      L[i] += 1
用列表表达式更好：
>>> [x+1 for x in L]

# 迭代和推导

 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次迭代，而每一次迭代得到的结果会作为下一次迭代的初始值。

 列表推导是对可迭代对象中的项应用一个表达式的for循环的一种近似形式。

 **可迭代对象**，本质上是序列观念的一种通用化，如果对象是实际保存的序列或者可以在迭代工具上下文中一次产生一个结果的对象，那么都可以看作是可迭代的。总之，可迭代对象包括实际序列，以及能按照需求计算的虚拟序列。

**可迭代对象**（iterable）指一个支持iter调用的对象。
**迭代器**（iterator）指一个支持next(I)调用的对象。
**生成器**（generator）指能自动支持迭代协议的对象，因此生成器本身就是可迭代对象，不过所有的生成器都能产生和结果。
**迭代协议**：所有带有__next__方法的对象会前进到下一个结果，而当到达一系列结果的末尾时，__next__会引发StopIteration异常，这种对象在Python中也称为迭代器。

## 完整的迭代协议

该协议基于分别用在不同的两个步骤中的两种对象：

1. 可迭代对象：迭代的被调对象，其__iter__方法被iter函数所调用。
2. 迭代器对象：可迭代对象的返回结果，在迭代过程中实际提供值的对象。它的__next__方法被next运行，并在结束时出发StopIteration异常。
文件本身就是迭代器，只支持一次迭代，它有自己的__next__方法，不需要返回一个不同的对象。
列表等内置对象，由于本身不是迭代器，因此支持多次迭代，必须用iter来启东迭代：

>>> L = [1,2,3]
>>> I = iter(L)
>>> I.**next**()
1
>>> next(I)
2

for循环在开始时，首先把可迭代对象传入内置函数iter，拿到一个迭代器。而iter调用返回的迭代器对象有着所需的next方法。iter函数与next和__next__很像，在它内部调用了__iter__方法。

## 扩展的列表推导语法

- 筛选分句：if

>>> lines = [line.rstrip() for line in open('script2.py') if line[0] == 'p']

- 嵌套循环：for

>>> [x + y for x in 'abc' for y in 'lmn']
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']

map是一个内置函数，作用是把一个函数调用应用于传入的可迭代对象中的每一项。
>>> map(str.upper, open('script2.py'))
<map object at 0x00000000029476D8>
>>> list(map(str.upper, open('script2.py')))
['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X=2\n']

*arg形式，会把一个集合的值解包为单个的参数：
>>> f(*[1,2,3,4])

# 文档

## Python文档资源

形式    作用

# 注释   源文件文档

dir函数 以列表显示对象中可用的属性
文档字符串:**doc**    附加在对象上的源文件文档
PyDoc:help函数      交互式命令行中的对象帮助
PyDoc:HTML报告      浏览器中的模块文档
Sphinx第三方工具    为大型项目提供更丰富的文档
标准手册集      官方的语言和库描述
网络资源        在线教程、示例等
已出版的书籍    商业化加工后的参考文本

>>> [a for a in dir(list) if not a.startswith('__')]

不要期待在原位置修改对象的函数会返回结果。像list.append、list.sort方法这样的原位置修改运算，并不会有返回值（除了None）。

字典keys方法返回的是试图而不是列表。

# 函数基础

**函数**就是将一些语句集合在一起的组件，从而让它们能够不止一次地在程序中运行（可以通过它们的名字来使用它们的打包的过程）。

## 函数相关的语句和表达式

语句或表达式            示例
调用表达式             myfuc("spam", "eggs", meat=ham, *rest)
def                   def printer(message):\ print('Hello' + message)
return                def adder(a, b=1,*c):\ return a+b+c[0]
global                x = 'old'\ def changer():\ global x; x = 'new'
nonlocal              def outer():\ x = 'old'\ def changer():\ nonlocal x; x = 'new'
yield                 def squares(x):\ for i in range(x): yield i**2
lambda                funcs = [lambda x: x**2, lambda x: x**3]

函数主要扮演两个角色：一是最大化代码重用和最小化代码冗余；二是过程分解。独立地实现较小的任务要比一次完成整个过程要容易得多。

def是可执行的代码。Python的函数是由一条新语句编写的，即def。可以将def理解成一条"="赋值语句：它在运行时给一个变量名赋值。

def创建了一个对象并将其赋值给某一变量名。当Python运行到def语句是，将生成一个新的函数对象并将其赋值给这个函数名。和所有的赋值一样，函数名变成了一个函数对象的引用。

lambda创建一个对象并将其作为结果返回。也可以用lambda表达式创建函数，这一功能允许我们把函数定义内联到语法上def语句不能工作的地方。

return将一个结果对象传回给调用者。

yield向调用者发回一个结果对象，但是回记住它离开的位置。

global声明了一个模块级的可被赋值的变量。变量名会在它的作用域也就是变量存储的地方被找到，而变量名与作用域的绑定是由实赋值语句实现的。

nonlocal声明了一个需要被赋值的外层函数变量。

参数是通过赋值（对象引用）传递给函数的。

除非你显式指明形式参数与实际参数的对应，否则实际参数按位置赋值给形式参数。通过*pargs和**kargs参数形式可以接收任意数量的实际参数。

参数、返回值与变量不需要被声明。

函数名并没有什么特别之处，关键在函数名所引用的那个对象：
>>> othername = func
>>> othername()
这里函数被赋值给一个不同的变量名，并通过新的变量名进行了调用。函数不过是对象，它们在程序运行时被明确地记录在内存中。实际上，除了调用外，函数允许将任意属性附加到其中以供之后使用：
>>> def func():
>>> func()
>>> func.attr = value

Python中的多态：
表达式x*y的意义完全取决于x和y的对象类型。实际上，*作为一个分派机制，将执行的控制权移交给被处理的对象。这种依赖类型的行为称为多态。只要对象支持所预期的接口（也称为协议），函数就能处理它们。从宏观上说，我们在Python中为对象接口编程，而不是数据类型。

# 作用域

Python创建、改变或查找变量名都是在所谓的命名空间（变量名存在的地方）进行的。

Python中一切与变量名有关的事件（包括作用域的分类），都发生在赋值的时候。

由于变量名最初没有声明，Python将一个变量名被赋值的地点关联为（绑定给）一个特定的命名空间，也就是它的可见范围。

变量可以在3个不同的地方被赋值，分别对应3种不同的作用域：

- 如果一个变量在def内赋值，它对于该函数而言是局部的。
- 如果在一个外层的def中赋值，对于内层的函数来说，它是非局部nonlocal的。
- 如果在所有def外赋值，它对于整个文件来说是全局的。

在开始编写函数之前，我们先前编写的所有代码都位于模块的顶层（也就是说，没有嵌套在def内），所以我们使用的名称要么存在于模块文件本身，要么就是Python预先定义好的内置名称。

从技术上讲，交互式命令行是一个名为__main__的模块，它可以打印结果，但不会保存其代码；在其他方面，它都与模块文件的顶层相同。

函数定义个局部作用域，而模块定义了具有如下属性的全局作用域：

- 外围模块是全局作用域。每一个模块都是一个全局作用域，也就是一个创建于模块文件顶层的变量的命名空间。模块被导入后，相对外部世界而言全局变量就成了模块对象的属性，但是在这个模块文件自身中也能像简单变量一样使用全局变量。
- 全局作用域的作用范围仅限于单个文件。别被这里的“全局”所迷惑，这里的全局指的是一个文件的顶层的变量名仅对于这个而文件内部的代码而言是全局的。在Python中是没有一个跨文件的单一且无所不包的全局作用域概念的。相反，变量名被划分到一个个模块中，并且你必须明确地导入一个模块文件才能使用这个文件中定义的变量名。当你在Python中听到“全局”时，你就应该联想到“模块”。
- 赋值的变量名除非被声明为global或nonlocal，否则均为局部变量。
- 所有其他的变量名都是外层函数的局部变量、全局变量或内置变量。
- 函数的每次调用都会创建一个新的局部作用域。每一条def语句（以及lambda表达式）都定义了一个新的局部作用域，局部作用域实际上对应于一次函数调用。

一个函数内部任何类型的赋值都会把一个名称划定为局部的。这包括=语句、import中的模块名、def中的函数名、函数形式参数名等。相反，原位置改变对象并不会把变量划分为局部变量，只有对变量名赋值才可以。

## 变量名解析：LEGB规则

变量名引用至多在四种作用域内进行查找：首先是局部（Local），其次是外层的函数（External），之后是全局（Global），最后是内置（Build-in）。

**内置作用域**仅仅是一个名为builtins的内置模块，但是必须导入builtins之后才能使用内置作用域，因为名称builtins本身没有预先内置。

global语句告诉Python函数计划生成一个或多个全局变量名，也就是说，存在于整个模块内部作用域的变量名。

模块的一个要点：通过在文件的层次上隔离变量，它们避免了跨文件的名称冲突，这与局部变量避免跨函数的名称冲突的方式很想。一个模块文件的全局作用域一旦被导入就成了这个模块对象的一个属性命名空间：导入者自动得到这个被导入的模块文件的所有全局变量的访问权，因为在一个文件被导入后，它的全局作用域就转变为一个对象的属性命名空间。

文件间进行通信的最好办法就是通过调用函数，传递参数，然后得到其返回值。

嵌套的作用域对应于程序源代码文本中物理上和句法上的嵌套代码结构。

## 工厂函数：闭包

**闭包（closure）**也叫工厂函数（factory function），能够记忆外层作用域里的值，不管那些嵌套作用域是否还在内存中存在。
>>> def maker(N):
      def action(X):
        return X**N
      return action
>>> f = maker(2)
>>> f
<function maker.<locals>.action at 0x0000000002A4A158>
>>> f(3)
9
>>> g = maker(3)
>>> g(4)
64
>>> f(4)
16
这定义了一个外层函数，用来简单生成并返回一个嵌套的函数，却并不调用这个内嵌的函数：maker创造出action，但知识简单地返回action而不执行它。如果调用外部的函数，我们得到的是生成的内嵌函数的一个引用。
这里最不平常的一点是，虽然在调用action时maker已经返回了值并退出，但是内嵌的函数记住了整数2，即maker内部的函数N的值。实际上，在外层嵌套局部作用域内的N被作为执行的状态信息保留了下来，并附加到生成action函数上，这也是当他稍后被调用是我们返回其参数平方的原因。每次对这样一个工厂函数的调用，都将得到属于调用自己的状态信息的集合。

lambda是个表达式，生成之后会调用的一个形函数，与def很相似。不过由于它是一个表达式，因此能用在def不能使用的地方。

nonlocal的作用域查找被限定在外层的def中。当执行一条nonlocal语句时，nonlocal名称必须已经在一个外层def作用域中被赋值过，也就是说，你不能通过赋值动态地在外层作用域中创建一个新的nonlocal名称。global可以在内层中创建全局变量。

# 参数

函数传递参数时的一些关键点：

- 参数的传递是通过自动将对象赋值给局部变量名来实现的。函数参数在实际中只不过是Python赋值的又一例子而已。因为引用是以指针的形式实现的，所有的参数实际上都是通过指针传入的。作为参数被传递的对象从来不会自动复制。
- 在函数内部赋值参数名不会影响调用者。在函数运行时，函数头部的参数名是一个新的、局部的变量名，这个变量名是在函数的局部作用域内的。
- 改变函数的可变对象参数的值也许会对调用者有影响。因为是直接把传入的对象赋值给参数，函数能够原位置改变传入的可变对象，因此结果可能会影响调用者。
- 不可变参数本质上传入了“值”。
- 可变对象本质上传入了“指针”。

return能返回任意种类的对象，所以它也能返回多个值，做法是将这些值封装进一个元组或其他的集合类型中。

## 特殊的参数匹配模式

你可以通过形式参数名、提供默认的参数值以及对额外参数使用容器等三种方法来制定匹配。

匹配模式大纲：

- 位置次序：从左至右进行匹配。
- 关键字参数：通过参数名进行匹配。
- 默认值参数：为没有传入值的可选参数制定参数值。
- 可变长参数（Varargs）收集：收集任意多的基于位置或关键字的参数。函数能够用一个*或两个**开头的特殊参数，来收集任意多的额外参数。
- 可变长参数解包：传入任意多的基于位置或关键字的参数。调用者也能使用*语法去将参数集合解包称单个参数。这个*与函数头部的*恰恰相反；在函数头部的*意味着搜集任意多的参数，而在调用者中意味着解包任意多的参数并将它们作为离散的值单独传入。
- keyword-only参数：必须按照名称传递的参数。

Python要求你所编写的参数匹配模式可选部分遵循以下规则：

- 在函数调用时，参数必须按此顺序出现：所有基于位置的参数（value），之后是所有关键字参数（name=value）和*iterable形式的组合，之后是**dict形式。
- 在函数头部，参数必须按此顺序出现：所有一般参数(name)，之后是所有默认值参数(name=value)，之后是*name形式，之后是所有name或name=value的keyword-only参数，之后是**name形式。

Python内部使用以下步骤在赋值前匹配参数：

1. 通过位置分配无关键字参数。
2. 通过匹配名称分配关键字参数。
3. 将剩下的非关键字参数分配到*name元组中。
4. 将剩下的关键字参数分配到**name字典中。
5. 把默认值分配给头部未得到匹配的参数。
在此之后，Python会检查以确保每个参数只被传入了一个值。如果不是这样，将引发一个错误。

函数头部中的参数名称还可以有一个注解值，其形式为name：value。函数自身也可以有一个注解值，以def f()->value的形式给出。

注意，如果你讲一个默认值参数编写为一个可变对象(例如，def f(a=[]))，同一个可变对象会在函数的所有调用中被反复地使用。最终的而效果是这个参数会默认从上一次调用中继续持有它的值，而不是重置为在def头部定义的原始值。为了每次都重置一个新的值，你需要把赋值语句移到函数的函数体中。可变默认值参数允许状态记忆，但这通常违背直觉。

在函数定义中把不能匹配的基于位置的参数搜集到一个元组中：
>>> def f(*args):print(args)
>>> f()
()
>>> f(1)
(1,)

**特性与之类似，但是它只对关键字参数有效。
>>> def (**args):print(args)
>>> f()
{}
>>> f(a=1,b=2)
{'a':1,'b'=2}

在调用时的*pargs形式是一个迭代上下文，因此从技术上讲它接受所有的可迭代对象，而不仅仅是元组或其他序列。

特殊的“可变长参数”调用的真正强大之处在于，在编写一段脚本之前不需要知道一个函数调用需要多少参数。
>>> def tracer(func, *pargs, **kargs):
      print('calling:', func.**name**)
return func(*pargs,**kargs)
    def func(a,b,c,d):
      return a+b+c+d
    print(tracer(func,1,2,c=3,d=4))

keyword-only参数编写为出现在参数列表中*args之后的有名参数。
>>> def kwonly(a,*b,c):
      print(a,b,c)
>>> kwonly(1,2,c=3)

- 上式c必须通过关键字参数进行赋值。

keyword-only参数必须编写在*args之后，**args之前。

keyword-only参数让一个函数既接受任意多个要处理的基于位置参数又接受作为关键字传入的配置项这件事变得容易。

内置版本的函数工作起来基本上与我们自己编写的函数一样，不过处于优化运行速度的目的采用C语言编写。

# 函数的高级话题

之所以使用函数，部分是由于函数的接口。

如何将任务分解成更为有针对性的函数（内聚性）、函数将如何通信（耦合性）。

函数设计原则：

- 耦合性：在输入时使用参数，输出时使用return语句。
- 耦合性：只在真正必要的情况下使用全局变量。
- 耦合性：不要改变可变类型的参数，除非调用者希望这样做。
- 内聚性：每一个函数都应该有一个单一的、统一的目标。
- 大小：每一个函数应该相对较小。
- 耦合性：避免直接改变其他模块文件中的变量。
- 通常，应该尽可能把函数和其他编程组件对外部的依赖性最小化。函数的自包含性越好，它就越容易被理解、复用和修改。

在几乎所有情况下，递归在内存空间和执行时间方面都较使用循环效率低。但递归能够遍历任意形状的结构。

在内部，Python通过在每一次递归调用时把信息压入调用栈来实现递归。

标准Python限制了运行时调用栈的深度，为扩大这一上限，可以使用sys模块：
>>> sys.getrecursionlimit()
1000
>>> sys.setrecursionlimit(10000)

递归式一种强大的工具，但只有在你理解并掌控它的时候才能发挥出巨大的威力。

Python中的函数是不折不扣的对象，其本身全部存储在内存块中。

函数对象支持一个特殊操作：它们可以由一个函数表达式后面的括号中的列表参数调用。

def语句中的名称并没有什么特殊含义：它知识当前作用域中的一个变量赋值，就好像它出现在=符号的左边一样。在def运行之后，函数名仅仅是一个对象的引用——我们可以自由地把这个对象赋值给其他的名称并且通过任何引用来调用它。

## 匿名函数：lambda

除了def语句之外，Python还提供了一种生成函数对象的表达式形式lambda。与def一样，这个表达式创建了一个之后能调用的函数，但是它返回该函数本身而不是将其赋值给一个变量。
lambda的一般形式： lambda argument1,argument2...argumentN: expression using argtuments
可以这样理解lambda，冒号（：）前是参数列表，冒号后是个表达式（return）语句。

- lambda是一个表达式，而不是语句。因此可以出现在def不允许出现的地方。
- lambda的主体是一个单独的表达式，而不是一个代码块。

默认参数也能在lambda参数中使用：
>>> x = (lambda a='fee',b='fie',c='foe': a+b+c)
>>> x('wee')
'weefiefoe'

lambda经常用来编写跳转表：
>>> L = [lambda x: x**2,
         lambda x: x**3,
         lambda x: x**4]
>>> for f in L:
      print(f(2))
    print(L[2](3))
  
print是一个调用表达式，而不是语句。表达式返回一个“值”，语句是过程控制流。

## 函数式编程工具

Python混合支持多种编程范式：过程式（使用基础的语句），面向对象式（使用类）和函数式。

Python提供了一整套进行函数式编程的内置工具，它们把函数作用于序列和其他可迭代对象。包括在一个可迭代对象的各项上嗲用函数的工具（map），使用一个测试函数来过滤项的工具（filter），还有把函数作用在成对的项上来运行结果的工具（reduce）。

- 可迭代对象上映射函数：map
map函数将被传入的函数作用到一个可迭代对象的每一个元素上，并返回包含了所有这些函数调用结果的一个列表。

>>> counters = [1,2,3,4]
>>> def inc(x): return x+10
>>> list(map(inc, conters))
[11,12,13,14]

- 选择可迭代对象中的元素：filter
filter和reduce分别实现了给予一个测试函数选择可迭代对象的元素，以及向“元素对”应用函数的功能。

>>> list(range(-5,5))
[-5,-4,-3,-2,-1,0,1,2,3,4]
>>> list(filter((lambda x: x>0),range(-5,5)))

- 合并可迭代对象中的元素：reduce
函数式reduce调用接受并处理一个迭代器，但它本身不是一个可迭代对象，它会返回一个单独的结果。

>>> from functools import reduce
>>> reduce((lambda x,y:x+y),[1,2,3,4])
10
>>> reduce((lambda x,y:x*y),[1,2,3,4])
24

# 推导和生成

列表推导将任意一个表达式而不是一个函数应用于一个迭代对象中的元素。

**标准推导语法**
在最简单的形式下，必须编写一个增量表达式和一个单独的for分句：
- [expression for target in iterable]
通过列表推导结构：
- [expression for target1 in iterable1 if condition1
              for target2 in iterable2 if condition2
              for targetN in iterableN if conditionN]
>>> res = [x+y for x in [0,1,2] for y in [100,200,300]]
>>> res
[100,200,300,101,201,301,102,202,302]

map函数和列表推导的最大区别是：map是一个可迭代对象，按需产生结果；为了达到同样的内存节省和运行时间加快，列表推导必须编写为生成器表达式。

让用户定义的操作推迟产生结果：
1. 生成器函数：使用常规的def语句进行编写，但是使用yield语句一次返回一个结果，在每次结果产生之间挂起和恢复他们的状态。
2. 生成器表达式：类似列表推导，但它们返回按需产生结果的一个对象，而不是创建一个结果列表。

生成器在适当情况下是一种很强大的工具。

可以传回一个值并随后从其挂起的地方继续的函数叫**生成器函数**，因为他们随着时间产生一系列的值。

当创建时，生成器函数被编译成一个支持迭代协议的对象，并在调用的时候他们不返回一个结果：他们返回一个可以出现在任何迭代上下文中的结果生成器。

